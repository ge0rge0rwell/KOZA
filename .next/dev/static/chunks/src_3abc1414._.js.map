{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/hooks/useLocalStorage.js"],"sourcesContent":["import { useState, useEffect } from 'react';\n\nexport default function useLocalStorage(key, initialValue) {\n    const [storedValue, setStoredValue] = useState(() => {\n        if (typeof window === 'undefined') return initialValue;\n        try {\n            const item = window.localStorage.getItem(key);\n            const parsed = item ? JSON.parse(item) : initialValue;\n            return parsed !== null ? parsed : initialValue;\n        } catch (error) {\n            console.log(error);\n            return initialValue;\n        }\n    });\n\n    const setValue = (value) => {\n        try {\n            const valueToStore = value instanceof Function ? value(storedValue) : value;\n            setStoredValue(valueToStore);\n            if (typeof window !== 'undefined') {\n                window.localStorage.setItem(key, JSON.stringify(valueToStore));\n            }\n        } catch (error) {\n            console.log(error);\n        }\n    };\n\n    return [storedValue, setValue];\n}\n"],"names":[],"mappings":";;;;AAAA;;;AAEe,SAAS,gBAAgB,GAAG,EAAE,YAAY;;IACrD,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,yKAAQ;oCAAC;YAC3C;;YACA,IAAI;gBACA,MAAM,OAAO,OAAO,YAAY,CAAC,OAAO,CAAC;gBACzC,MAAM,SAAS,OAAO,KAAK,KAAK,CAAC,QAAQ;gBACzC,OAAO,WAAW,OAAO,SAAS;YACtC,EAAE,OAAO,OAAO;gBACZ,QAAQ,GAAG,CAAC;gBACZ,OAAO;YACX;QACJ;;IAEA,MAAM,WAAW,CAAC;QACd,IAAI;YACA,MAAM,eAAe,iBAAiB,WAAW,MAAM,eAAe;YACtE,eAAe;YACf,wCAAmC;gBAC/B,OAAO,YAAY,CAAC,OAAO,CAAC,KAAK,KAAK,SAAS,CAAC;YACpD;QACJ,EAAE,OAAO,OAAO;YACZ,QAAQ,GAAG,CAAC;QAChB;IACJ;IAEA,OAAO;QAAC;QAAa;KAAS;AAClC;GA1BwB"}},
    {"offset": {"line": 51, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/config.js"],"sourcesContent":["export const APP_CONFIG = {\n    NAME: \"KOZA\",\n    VERSION: \"2.0.0\"\n};\n\nexport const API_CONFIG = {\n    OPENROUTER_API_KEY: process.env.NEXT_PUBLIC_OPENROUTER_API_KEY || \"\"\n};\n\nexport const FIREBASE_CONFIG = {\n    apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY || \"\",\n    authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN || \"\",\n    projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID || \"\",\n    storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET || \"\",\n    messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID || \"\",\n    appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID || \"\"\n};\n\nexport const ANALYTICS_CONFIG = {\n    measurementId: process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID || \"\"\n};\n"],"names":[],"mappings":";;;;;;;;;;AAMwB;AANjB,MAAM,aAAa;IACtB,MAAM;IACN,SAAS;AACb;AAEO,MAAM,aAAa;IACtB,oBAAoB,iHAA8C;AACtE;AAEO,MAAM,kBAAkB;IAC3B,QAAQ,+EAA4C;IACpD,YAAY,oEAAgD;IAC5D,WAAW,oDAA+C;IAC1D,eAAe,wEAAmD;IAClE,mBAAmB,oDAAwD;IAC3E,OAAO,iFAA2C;AACtD;AAEO,MAAM,mBAAmB;IAC5B,eAAe,oDAA6C;AAChE"}},
    {"offset": {"line": 87, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/utils/userPresence.js"],"sourcesContent":["/**\n * User Presence Tracker\n * Tracks active users for admin analytics\n */\n\nclass UserPresenceTracker {\n    constructor() {\n        this.activeUsers = new Set();\n        this.sessionId = this.generateSessionId();\n        this.startTracking();\n    }\n\n    generateSessionId() {\n        return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    }\n\n    startTracking() {\n        if (typeof window === 'undefined') return;\n\n        // Add current session\n        this.activeUsers.add(this.sessionId);\n\n        // Cleanup on page unload\n        window.addEventListener('beforeunload', () => {\n            this.activeUsers.delete(this.sessionId);\n        });\n\n        // Simulate presence updates (in production, this would sync with Firebase)\n        // For now, track local sessions\n        this.cleanupInterval = setInterval(() => {\n            // Cleanup expired sessions (optional)\n            // In a real system, this would query Firebase\n        }, 60000);\n    }\n\n    getActiveUserCount() {\n        // In production, this would query Firebase Realtime Database\n        // For now, return 1 (current user)\n        return this.activeUsers.size;\n    }\n\n    cleanup() {\n        if (this.cleanupInterval) {\n            clearInterval(this.cleanupInterval);\n        }\n        this.activeUsers.delete(this.sessionId);\n    }\n}\n\nexport const userPresenceTracker = new UserPresenceTracker();\n"],"names":[],"mappings":";;;;AAAA;;;CAGC,GAED,MAAM;IACF,aAAc;QACV,IAAI,CAAC,WAAW,GAAG,IAAI;QACvB,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,iBAAiB;QACvC,IAAI,CAAC,aAAa;IACtB;IAEA,oBAAoB;QAChB,OAAO,CAAC,QAAQ,EAAE,KAAK,GAAG,GAAG,CAAC,EAAE,KAAK,MAAM,GAAG,QAAQ,CAAC,IAAI,MAAM,CAAC,GAAG,IAAI;IAC7E;IAEA,gBAAgB;QACZ;;QAEA,sBAAsB;QACtB,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS;QAEnC,yBAAyB;QACzB,OAAO,gBAAgB,CAAC,gBAAgB;YACpC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS;QAC1C;QAEA,2EAA2E;QAC3E,gCAAgC;QAChC,IAAI,CAAC,eAAe,GAAG,YAAY;QAC/B,sCAAsC;QACtC,8CAA8C;QAClD,GAAG;IACP;IAEA,qBAAqB;QACjB,6DAA6D;QAC7D,mCAAmC;QACnC,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI;IAChC;IAEA,UAAU;QACN,IAAI,IAAI,CAAC,eAAe,EAAE;YACtB,cAAc,IAAI,CAAC,eAAe;QACtC;QACA,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS;IAC1C;AACJ;AAEO,MAAM,sBAAsB,IAAI"}},
    {"offset": {"line": 139, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/utils/localAnalytics.js"],"sourcesContent":["/**\n * Local Analytics Tracker\n * Stores analytics data locally for admin panel display\n */\n\nimport { userPresenceTracker } from './userPresence';\n\nclass LocalAnalytics {\n    constructor() {\n        this.sessionStart = Date.now();\n        this.pageViews = [];\n        this.events = [];\n        this.maxItems = 100;\n    }\n\n    trackPageView(path) {\n        this.pageViews.push({\n            path,\n            timestamp: Date.now()\n        });\n\n        if (this.pageViews.length > this.maxItems) {\n            this.pageViews.shift();\n        }\n    }\n\n    trackEvent(category, action, label) {\n        this.events.push({\n            category,\n            action,\n            label,\n            timestamp: Date.now()\n        });\n\n        if (this.events.length > this.maxItems) {\n            this.events.shift();\n        }\n    }\n\n    getStats() {\n        const now = Date.now();\n        const sessionDuration = now - this.sessionStart;\n\n        // Calculate average session time (simplified)\n        const avgSessionMinutes = Math.floor(sessionDuration / 60000);\n        const avgSessionSeconds = Math.floor((sessionDuration % 60000) / 1000);\n\n        // Count unique paths\n        const uniquePaths = new Set(this.pageViews.map(pv => pv.path));\n\n        // Event breakdown\n        const eventsByCategory = {};\n        this.events.forEach(event => {\n            eventsByCategory[event.category] = (eventsByCategory[event.category] || 0) + 1;\n        });\n\n        return {\n            totalPageViews: this.pageViews.length,\n            uniquePages: uniquePaths.size,\n            totalEvents: this.events.length,\n            sessionDuration: `${avgSessionMinutes}m ${avgSessionSeconds}s`,\n            activeUsers: userPresenceTracker.getActiveUserCount(),\n            eventsByCategory,\n            recentPageViews: this.pageViews.slice(-10).reverse(),\n            recentEvents: this.events.slice(-10).reverse()\n        };\n    }\n\n    clearData() {\n        this.pageViews = [];\n        this.events = [];\n        this.sessionStart = Date.now();\n    }\n}\n\nexport const localAnalytics = new LocalAnalytics();\n"],"names":[],"mappings":";;;;AAAA;;;CAGC,GAED;;AAEA,MAAM;IACF,aAAc;QACV,IAAI,CAAC,YAAY,GAAG,KAAK,GAAG;QAC5B,IAAI,CAAC,SAAS,GAAG,EAAE;QACnB,IAAI,CAAC,MAAM,GAAG,EAAE;QAChB,IAAI,CAAC,QAAQ,GAAG;IACpB;IAEA,cAAc,IAAI,EAAE;QAChB,IAAI,CAAC,SAAS,CAAC,IAAI,CAAC;YAChB;YACA,WAAW,KAAK,GAAG;QACvB;QAEA,IAAI,IAAI,CAAC,SAAS,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE;YACvC,IAAI,CAAC,SAAS,CAAC,KAAK;QACxB;IACJ;IAEA,WAAW,QAAQ,EAAE,MAAM,EAAE,KAAK,EAAE;QAChC,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;YACb;YACA;YACA;YACA,WAAW,KAAK,GAAG;QACvB;QAEA,IAAI,IAAI,CAAC,MAAM,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,EAAE;YACpC,IAAI,CAAC,MAAM,CAAC,KAAK;QACrB;IACJ;IAEA,WAAW;QACP,MAAM,MAAM,KAAK,GAAG;QACpB,MAAM,kBAAkB,MAAM,IAAI,CAAC,YAAY;QAE/C,8CAA8C;QAC9C,MAAM,oBAAoB,KAAK,KAAK,CAAC,kBAAkB;QACvD,MAAM,oBAAoB,KAAK,KAAK,CAAC,AAAC,kBAAkB,QAAS;QAEjE,qBAAqB;QACrB,MAAM,cAAc,IAAI,IAAI,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAA,KAAM,GAAG,IAAI;QAE5D,kBAAkB;QAClB,MAAM,mBAAmB,CAAC;QAC1B,IAAI,CAAC,MAAM,CAAC,OAAO,CAAC,CAAA;YAChB,gBAAgB,CAAC,MAAM,QAAQ,CAAC,GAAG,CAAC,gBAAgB,CAAC,MAAM,QAAQ,CAAC,IAAI,CAAC,IAAI;QACjF;QAEA,OAAO;YACH,gBAAgB,IAAI,CAAC,SAAS,CAAC,MAAM;YACrC,aAAa,YAAY,IAAI;YAC7B,aAAa,IAAI,CAAC,MAAM,CAAC,MAAM;YAC/B,iBAAiB,GAAG,kBAAkB,EAAE,EAAE,kBAAkB,CAAC,CAAC;YAC9D,aAAa,sJAAmB,CAAC,kBAAkB;YACnD;YACA,iBAAiB,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,IAAI,OAAO;YAClD,cAAc,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,OAAO;QAChD;IACJ;IAEA,YAAY;QACR,IAAI,CAAC,SAAS,GAAG,EAAE;QACnB,IAAI,CAAC,MAAM,GAAG,EAAE;QAChB,IAAI,CAAC,YAAY,GAAG,KAAK,GAAG;IAChC;AACJ;AAEO,MAAM,iBAAiB,IAAI"}},
    {"offset": {"line": 213, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/utils/googleAnalytics.js"],"sourcesContent":["import ReactGA from 'react-ga4';\nimport { ANALYTICS_CONFIG } from '../config';\nimport { localAnalytics } from './localAnalytics';\n\nclass GoogleAnalytics {\n    constructor() {\n        this.initialized = false;\n        this.queue = [];\n    }\n\n    initialize() {\n        if (this.initialized || !ANALYTICS_CONFIG.measurementId || typeof window === 'undefined') {\n            return;\n        }\n\n        // Use requestIdleCallback or setTimeout to initialize without blocking LCP\n        const init = () => {\n            try {\n                ReactGA.initialize(ANALYTICS_CONFIG.measurementId, {\n                    gaOptions: {\n                        anonymizeIp: true,\n                    }\n                });\n                this.initialized = true;\n                console.log('ðŸ“Š Google Analytics initialized (non-blocking)');\n\n                // Process queued events\n                while (this.queue.length > 0) {\n                    const { type, args } = this.queue.shift();\n                    this[type](...args);\n                }\n            } catch (error) {\n                console.error('Failed to initialize Google Analytics:', error);\n            }\n        };\n\n        if (window.requestIdleCallback) {\n            window.requestIdleCallback(init);\n        } else {\n            setTimeout(init, 2000);\n        }\n    }\n\n    trackPageView(path) {\n        // Always track locally for admin panel\n        localAnalytics.trackPageView(path);\n\n        if (!this.initialized) {\n            this.queue.push({ type: 'trackPageView', args: [path] });\n            return;\n        }\n\n        try {\n            ReactGA.send({ hitType: 'pageview', page: path });\n        } catch (error) {\n            console.error('Failed to track page view:', error);\n        }\n    }\n\n    trackEvent(category, action, label, value) {\n        // Always track locally for admin panel\n        localAnalytics.trackEvent(category, action, label);\n\n        if (!this.initialized) {\n            this.queue.push({ type: 'trackEvent', args: [category, action, label, value] });\n            return;\n        }\n\n        try {\n            ReactGA.event({\n                category,\n                action,\n                label,\n                value\n            });\n        } catch (error) {\n            console.error('Failed to track event:', error);\n        }\n    }\n\n    setUserProperties(properties) {\n        if (!this.initialized) {\n            this.queue.push({ type: 'setUserProperties', args: [properties] });\n            return;\n        }\n\n        try {\n            ReactGA.set(properties);\n        } catch (error) {\n            console.error('Failed to set user properties:', error);\n        }\n    }\n\n    trackTiming(category, variable, value, label) {\n        if (!this.initialized) return;\n\n        try {\n            ReactGA.event({\n                category,\n                action: variable,\n                label,\n                value,\n                nonInteraction: true\n            });\n        } catch (error) {\n            console.error('Failed to track timing:', error);\n        }\n    }\n}\n\nexport const googleAnalytics = new GoogleAnalytics();\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAEA,MAAM;IACF,aAAc;QACV,IAAI,CAAC,WAAW,GAAG;QACnB,IAAI,CAAC,KAAK,GAAG,EAAE;IACnB;IAEA,aAAa;QACT,IAAI,IAAI,CAAC,WAAW,IAAI,CAAC,oIAAgB,CAAC,aAAa,IAAI,+CAAkB,aAAa;YACtF;QACJ;QAEA,2EAA2E;QAC3E,MAAM,OAAO;YACT,IAAI;gBACA,2JAAO,CAAC,UAAU,CAAC,oIAAgB,CAAC,aAAa,EAAE;oBAC/C,WAAW;wBACP,aAAa;oBACjB;gBACJ;gBACA,IAAI,CAAC,WAAW,GAAG;gBACnB,QAAQ,GAAG,CAAC;gBAEZ,wBAAwB;gBACxB,MAAO,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,EAAG;oBAC1B,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC,KAAK,CAAC,KAAK;oBACvC,IAAI,CAAC,KAAK,IAAI;gBAClB;YACJ,EAAE,OAAO,OAAO;gBACZ,QAAQ,KAAK,CAAC,0CAA0C;YAC5D;QACJ;QAEA,IAAI,OAAO,mBAAmB,EAAE;YAC5B,OAAO,mBAAmB,CAAC;QAC/B,OAAO;YACH,WAAW,MAAM;QACrB;IACJ;IAEA,cAAc,IAAI,EAAE;QAChB,uCAAuC;QACvC,mJAAc,CAAC,aAAa,CAAC;QAE7B,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YACnB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gBAAE,MAAM;gBAAiB,MAAM;oBAAC;iBAAK;YAAC;YACtD;QACJ;QAEA,IAAI;YACA,2JAAO,CAAC,IAAI,CAAC;gBAAE,SAAS;gBAAY,MAAM;YAAK;QACnD,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,8BAA8B;QAChD;IACJ;IAEA,WAAW,QAAQ,EAAE,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE;QACvC,uCAAuC;QACvC,mJAAc,CAAC,UAAU,CAAC,UAAU,QAAQ;QAE5C,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YACnB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gBAAE,MAAM;gBAAc,MAAM;oBAAC;oBAAU;oBAAQ;oBAAO;iBAAM;YAAC;YAC7E;QACJ;QAEA,IAAI;YACA,2JAAO,CAAC,KAAK,CAAC;gBACV;gBACA;gBACA;gBACA;YACJ;QACJ,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,0BAA0B;QAC5C;IACJ;IAEA,kBAAkB,UAAU,EAAE;QAC1B,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;YACnB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC;gBAAE,MAAM;gBAAqB,MAAM;oBAAC;iBAAW;YAAC;YAChE;QACJ;QAEA,IAAI;YACA,2JAAO,CAAC,GAAG,CAAC;QAChB,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,kCAAkC;QACpD;IACJ;IAEA,YAAY,QAAQ,EAAE,QAAQ,EAAE,KAAK,EAAE,KAAK,EAAE;QAC1C,IAAI,CAAC,IAAI,CAAC,WAAW,EAAE;QAEvB,IAAI;YACA,2JAAO,CAAC,KAAK,CAAC;gBACV;gBACA,QAAQ;gBACR;gBACA;gBACA,gBAAgB;YACpB;QACJ,EAAE,OAAO,OAAO;YACZ,QAAQ,KAAK,CAAC,2BAA2B;QAC7C;IACJ;AACJ;AAEO,MAAM,kBAAkB,IAAI"}},
    {"offset": {"line": 343, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/services/firebase.js"],"sourcesContent":["import { initializeApp } from \"firebase/app\";\nimport { getAuth } from \"firebase/auth\";\nimport { getFirestore } from \"firebase/firestore\";\n\nconst firebaseConfig = {\n    apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,\n    authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,\n    projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,\n    storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET,\n    messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID,\n    appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,\n    measurementId: process.env.NEXT_PUBLIC_GA_MEASUREMENT_ID\n};\n\n// Initialize Firebase\nconst app = initializeApp(firebaseConfig);\n\nlet analytics = null;\nif (typeof window !== \"undefined\") {\n    // Only initialize analytics on the client side\n    import(\"firebase/analytics\").then(({ getAnalytics, isSupported }) => {\n        isSupported().then(yes => yes && (analytics = getAnalytics(app)));\n    });\n}\n\nconst auth = getAuth(app);\nconst db = getFirestore(app);\n\nexport { app, analytics, auth, db };\n"],"names":[],"mappings":";;;;;;;;;;AAKY;AALZ;AAAA;AACA;AAAA;AACA;AAAA;;;;AAEA,MAAM,iBAAiB;IACnB,MAAM;IACN,UAAU;IACV,SAAS;IACT,aAAa;IACb,iBAAiB;IACjB,KAAK;IACL,aAAa;AACjB;AAEA,sBAAsB;AACtB,MAAM,MAAM,IAAA,oLAAa,EAAC;AAE1B,IAAI,YAAY;AAChB,wCAAmC;IAC/B,+CAA+C;IAC/C,mIAA6B,IAAI,CAAC,CAAC,EAAE,YAAY,EAAE,WAAW,EAAE;QAC5D,cAAc,IAAI,CAAC,CAAA,MAAO,OAAO,CAAC,YAAY,aAAa,IAAI;IACnE;AACJ;AAEA,MAAM,OAAO,IAAA,wKAAO,EAAC;AACrB,MAAM,KAAK,IAAA,kLAAY,EAAC"}},
    {"offset": {"line": 391, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/machines/authMachine.js"],"sourcesContent":["import { setup, assign } from 'xstate';\n\nexport const authMachine = setup({\n    types: {\n        context: {},\n        events: {}\n    },\n    actions: {\n        assignUser: assign({\n            user: ({ event }) => event.user\n        }),\n        clearUser: assign({\n            user: null\n        }),\n        assignError: assign({\n            error: ({ event }) => event.error\n        })\n    }\n}).createMachine({\n    id: 'auth',\n    initial: 'checking',\n    context: {\n        user: null,\n        error: null\n    },\n    states: {\n        checking: {\n            on: {\n                'AUTH.CHECK_COMPLETE': [\n                    {\n                        guard: ({ event }) => !!event.user,\n                        target: 'authenticated',\n                        actions: 'assignUser'\n                    },\n                    {\n                        target: 'unauthenticated'\n                    }\n                ]\n            }\n        },\n        unauthenticated: {\n            on: {\n                'AUTH.LOGIN_START': {\n                    target: 'authenticating',\n                    actions: 'clearUser' // Clear specific error if needed\n                }\n            }\n        },\n        authenticating: {\n            on: {\n                'AUTH.LOGIN_SUCCESS': {\n                    target: 'authenticated',\n                    actions: 'assignUser'\n                },\n                'AUTH.LOGIN_FAILURE': {\n                    target: 'unauthenticated', // or 'error' state if we want to show a sticky error\n                    actions: 'assignError'\n                }\n            }\n        },\n        authenticated: {\n            on: {\n                'AUTH.LOGOUT_START': {\n                    target: 'unauthenticated',\n                    actions: 'clearUser'\n                },\n                'AUTH.UPDATE_USER': {\n                    actions: 'assignUser'\n                }\n            }\n        }\n    }\n});\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AAEO,MAAM,cAAc,IAAA,0LAAK,EAAC;IAC7B,OAAO;QACH,SAAS,CAAC;QACV,QAAQ,CAAC;IACb;IACA,SAAS;QACL,YAAY,IAAA,sNAAM,EAAC;YACf,MAAM,CAAC,EAAE,KAAK,EAAE,GAAK,MAAM,IAAI;QACnC;QACA,WAAW,IAAA,sNAAM,EAAC;YACd,MAAM;QACV;QACA,aAAa,IAAA,sNAAM,EAAC;YAChB,OAAO,CAAC,EAAE,KAAK,EAAE,GAAK,MAAM,KAAK;QACrC;IACJ;AACJ,GAAG,aAAa,CAAC;IACb,IAAI;IACJ,SAAS;IACT,SAAS;QACL,MAAM;QACN,OAAO;IACX;IACA,QAAQ;QACJ,UAAU;YACN,IAAI;gBACA,uBAAuB;oBACnB;wBACI,OAAO,CAAC,EAAE,KAAK,EAAE,GAAK,CAAC,CAAC,MAAM,IAAI;wBAClC,QAAQ;wBACR,SAAS;oBACb;oBACA;wBACI,QAAQ;oBACZ;iBACH;YACL;QACJ;QACA,iBAAiB;YACb,IAAI;gBACA,oBAAoB;oBAChB,QAAQ;oBACR,SAAS,YAAY,iCAAiC;gBAC1D;YACJ;QACJ;QACA,gBAAgB;YACZ,IAAI;gBACA,sBAAsB;oBAClB,QAAQ;oBACR,SAAS;gBACb;gBACA,sBAAsB;oBAClB,QAAQ;oBACR,SAAS;gBACb;YACJ;QACJ;QACA,eAAe;YACX,IAAI;gBACA,qBAAqB;oBACjB,QAAQ;oBACR,SAAS;gBACb;gBACA,oBAAoB;oBAChB,SAAS;gBACb;YACJ;QACJ;IACJ;AACJ"}},
    {"offset": {"line": 476, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/utils/achievements.js"],"sourcesContent":["/**\n * Achievement system\n */\n\nexport const ACHIEVEMENTS = [\n    {\n        id: 'first_story',\n        name: 'Ä°lk Hikaye',\n        description: 'Ä°lk hikayeni oluÅŸtur',\n        icon: 'ðŸ“–',\n        xp: 100,\n        condition: (stats) => stats.storiesCreated >= 1\n    },\n    {\n        id: 'story_master',\n        name: 'Hikaye UstasÄ±',\n        description: '10 hikaye oluÅŸtur',\n        icon: 'âœ¨',\n        xp: 500,\n        condition: (stats) => stats.storiesCreated >= 10\n    },\n    {\n        id: 'first_game',\n        name: 'Ä°lk Oyun',\n        description: 'Ä°lk oyununu oluÅŸtur',\n        icon: 'ðŸŽ®',\n        xp: 100,\n        condition: (stats) => stats.gamesCreated >= 1\n    },\n    {\n        id: 'game_master',\n        name: 'Oyun UstasÄ±',\n        description: '10 oyun oluÅŸtur',\n        icon: 'ðŸ†',\n        xp: 500,\n        condition: (stats) => stats.gamesCreated >= 10\n    },\n    {\n        id: 'level_5',\n        name: 'YÃ¼kselen YÄ±ldÄ±z',\n        description: 'Seviye 5\\'e ulaÅŸ',\n        icon: 'â­',\n        xp: 200,\n        condition: (stats) => stats.level >= 5\n    },\n    {\n        id: 'level_10',\n        name: 'DÃ¶nÃ¼ÅŸÃ¼m Åžampiyonu',\n        description: 'Seviye 10\\'a ulaÅŸ',\n        icon: 'ðŸŒŸ',\n        xp: 500,\n        condition: (stats) => stats.level >= 10\n    },\n    {\n        id: 'xp_1000',\n        name: 'XP AvcÄ±sÄ±',\n        description: 'Toplam 1000 XP kazan',\n        icon: 'ðŸ’Ž',\n        xp: 250,\n        condition: (stats) => stats.totalXP >= 1000\n    },\n    {\n        id: 'daily_streak_7',\n        name: 'KararlÄ± KullanÄ±cÄ±',\n        description: '7 gÃ¼n Ã¼st Ã¼ste giriÅŸ yap',\n        icon: 'ðŸ”¥',\n        xp: 300,\n        condition: (stats) => stats.dailyStreak >= 7\n    }\n];\n\nexport const checkAchievements = (stats, unlockedAchievements = []) => {\n    const newAchievements = [];\n\n    for (const achievement of ACHIEVEMENTS) {\n        if (!unlockedAchievements.includes(achievement.id) && achievement.condition(stats)) {\n            newAchievements.push(achievement);\n        }\n    }\n\n    return newAchievements;\n};\n\nexport const getAchievementProgress = (achievementId, stats) => {\n    const achievement = ACHIEVEMENTS.find(a => a.id === achievementId);\n    if (!achievement) return 0;\n\n    // Calculate progress based on achievement type\n    if (achievementId.includes('story')) {\n        const target = achievementId === 'first_story' ? 1 : 10;\n        return Math.min((stats.storiesCreated / target) * 100, 100);\n    }\n\n    if (achievementId.includes('game')) {\n        const target = achievementId === 'first_game' ? 1 : 10;\n        return Math.min((stats.gamesCreated / target) * 100, 100);\n    }\n\n    if (achievementId.includes('level')) {\n        const target = parseInt(achievementId.split('_')[1]);\n        return Math.min((stats.level / target) * 100, 100);\n    }\n\n    if (achievementId.includes('xp')) {\n        const target = parseInt(achievementId.split('_')[1]);\n        return Math.min((stats.totalXP / target) * 100, 100);\n    }\n\n    if (achievementId.includes('streak')) {\n        const target = parseInt(achievementId.split('_')[2]);\n        return Math.min((stats.dailyStreak / target) * 100, 100);\n    }\n\n    return 0;\n};\n"],"names":[],"mappings":"AAAA;;CAEC;;;;;;;;AAEM,MAAM,eAAe;IACxB;QACI,IAAI;QACJ,MAAM;QACN,aAAa;QACb,MAAM;QACN,IAAI;QACJ,WAAW,CAAC,QAAU,MAAM,cAAc,IAAI;IAClD;IACA;QACI,IAAI;QACJ,MAAM;QACN,aAAa;QACb,MAAM;QACN,IAAI;QACJ,WAAW,CAAC,QAAU,MAAM,cAAc,IAAI;IAClD;IACA;QACI,IAAI;QACJ,MAAM;QACN,aAAa;QACb,MAAM;QACN,IAAI;QACJ,WAAW,CAAC,QAAU,MAAM,YAAY,IAAI;IAChD;IACA;QACI,IAAI;QACJ,MAAM;QACN,aAAa;QACb,MAAM;QACN,IAAI;QACJ,WAAW,CAAC,QAAU,MAAM,YAAY,IAAI;IAChD;IACA;QACI,IAAI;QACJ,MAAM;QACN,aAAa;QACb,MAAM;QACN,IAAI;QACJ,WAAW,CAAC,QAAU,MAAM,KAAK,IAAI;IACzC;IACA;QACI,IAAI;QACJ,MAAM;QACN,aAAa;QACb,MAAM;QACN,IAAI;QACJ,WAAW,CAAC,QAAU,MAAM,KAAK,IAAI;IACzC;IACA;QACI,IAAI;QACJ,MAAM;QACN,aAAa;QACb,MAAM;QACN,IAAI;QACJ,WAAW,CAAC,QAAU,MAAM,OAAO,IAAI;IAC3C;IACA;QACI,IAAI;QACJ,MAAM;QACN,aAAa;QACb,MAAM;QACN,IAAI;QACJ,WAAW,CAAC,QAAU,MAAM,WAAW,IAAI;IAC/C;CACH;AAEM,MAAM,oBAAoB,CAAC,OAAO,uBAAuB,EAAE;IAC9D,MAAM,kBAAkB,EAAE;IAE1B,KAAK,MAAM,eAAe,aAAc;QACpC,IAAI,CAAC,qBAAqB,QAAQ,CAAC,YAAY,EAAE,KAAK,YAAY,SAAS,CAAC,QAAQ;YAChF,gBAAgB,IAAI,CAAC;QACzB;IACJ;IAEA,OAAO;AACX;AAEO,MAAM,yBAAyB,CAAC,eAAe;IAClD,MAAM,cAAc,aAAa,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;IACpD,IAAI,CAAC,aAAa,OAAO;IAEzB,+CAA+C;IAC/C,IAAI,cAAc,QAAQ,CAAC,UAAU;QACjC,MAAM,SAAS,kBAAkB,gBAAgB,IAAI;QACrD,OAAO,KAAK,GAAG,CAAC,AAAC,MAAM,cAAc,GAAG,SAAU,KAAK;IAC3D;IAEA,IAAI,cAAc,QAAQ,CAAC,SAAS;QAChC,MAAM,SAAS,kBAAkB,eAAe,IAAI;QACpD,OAAO,KAAK,GAAG,CAAC,AAAC,MAAM,YAAY,GAAG,SAAU,KAAK;IACzD;IAEA,IAAI,cAAc,QAAQ,CAAC,UAAU;QACjC,MAAM,SAAS,SAAS,cAAc,KAAK,CAAC,IAAI,CAAC,EAAE;QACnD,OAAO,KAAK,GAAG,CAAC,AAAC,MAAM,KAAK,GAAG,SAAU,KAAK;IAClD;IAEA,IAAI,cAAc,QAAQ,CAAC,OAAO;QAC9B,MAAM,SAAS,SAAS,cAAc,KAAK,CAAC,IAAI,CAAC,EAAE;QACnD,OAAO,KAAK,GAAG,CAAC,AAAC,MAAM,OAAO,GAAG,SAAU,KAAK;IACpD;IAEA,IAAI,cAAc,QAAQ,CAAC,WAAW;QAClC,MAAM,SAAS,SAAS,cAAc,KAAK,CAAC,IAAI,CAAC,EAAE;QACnD,OAAO,KAAK,GAAG,CAAC,AAAC,MAAM,WAAW,GAAG,SAAU,KAAK;IACxD;IAEA,OAAO;AACX"}},
    {"offset": {"line": 594, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/machines/userMachine.js"],"sourcesContent":["import { setup, assign } from 'xstate';\nimport { checkAchievements } from '../utils/achievements';\n\nexport const userMachine = setup({\n    types: {\n        context: {},\n        events: {}\n    },\n    actions: {\n        updateLocalUser: assign({\n            user: ({ context, event }) => {\n                return { ...context.user, ...event.data };\n            }\n        }),\n        calculateXP: assign({\n            user: ({ context, event }) => {\n                const { amount } = event;\n                const prev = context.user;\n                const newXP = prev.xp + amount;\n                const newTotalXP = prev.totalXP + amount;\n\n                // This machine handles the *logic*, ensuring it's decoupled from UI\n                // We can emit a 'LEVEL_UP' event if needed, or just update state\n                if (newXP >= prev.nextLevelXp) {\n                    return {\n                        ...prev,\n                        xp: newXP - prev.nextLevelXp,\n                        level: prev.level + 1,\n                        nextLevelXp: Math.floor(prev.nextLevelXp * 1.5),\n                        totalXP: newTotalXP\n                    };\n                }\n\n                return {\n                    ...prev,\n                    xp: newXP,\n                    totalXP: newTotalXP\n                };\n            }\n        }),\n        checkAchievements: assign({\n            user: ({ context }) => {\n                // Wrapper around utility logic\n                const newAchievements = checkAchievements({\n                    storiesCreated: context.user.storiesCreated,\n                    gamesCreated: context.user.gamesCreated,\n                    level: context.user.level,\n                    totalXP: context.user.totalXP,\n                    dailyStreak: context.user.dailyStreak\n                }, context.user.achievements);\n\n                if (newAchievements.length > 0) {\n                    return {\n                        ...context.user,\n                        achievements: [...context.user.achievements, ...newAchievements.map(a => a.id)]\n                    };\n                }\n                return context.user;\n            }\n        })\n    }\n}).createMachine({\n    id: 'user',\n    initial: 'idle',\n    context: {\n        user: null, // Will be populated from storage or auth\n        syncStatus: 'idle', // 'idle' | 'syncing' | 'synced' | 'error'\n        lastError: null\n    },\n    states: {\n        idle: {\n            on: {\n                'USER.LOAD_DATA': {\n                    target: 'loading',\n                    actions: assign({ user: ({ event }) => event.data })\n                }\n            }\n        },\n        loading: {\n            always: 'ready'\n        },\n        ready: {\n            on: {\n                'USER.AWARD_XP': {\n                    actions: ['calculateXP', 'checkAchievements'] // Chained actions\n                },\n                'USER.SYNC_START': {\n                    target: 'syncing'\n                },\n                'USER.UPDATE_PROFILE': {\n                    actions: 'updateLocalUser'\n                }\n            }\n        },\n        syncing: {\n            on: {\n                'USER.SYNC_SUCCESS': {\n                    target: 'ready',\n                    actions: assign({ syncStatus: 'synced' })\n                },\n                'USER.SYNC_FAILURE': {\n                    target: 'ready',\n                    actions: assign({ syncStatus: 'error', lastError: ({ event }) => event.error })\n                }\n            }\n        }\n    }\n});\n"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;;;AAEO,MAAM,cAAc,IAAA,0LAAK,EAAC;IAC7B,OAAO;QACH,SAAS,CAAC;QACV,QAAQ,CAAC;IACb;IACA,SAAS;QACL,iBAAiB,IAAA,sNAAM,EAAC;YACpB,MAAM,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE;gBACrB,OAAO;oBAAE,GAAG,QAAQ,IAAI;oBAAE,GAAG,MAAM,IAAI;gBAAC;YAC5C;QACJ;QACA,aAAa,IAAA,sNAAM,EAAC;YAChB,MAAM,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE;gBACrB,MAAM,EAAE,MAAM,EAAE,GAAG;gBACnB,MAAM,OAAO,QAAQ,IAAI;gBACzB,MAAM,QAAQ,KAAK,EAAE,GAAG;gBACxB,MAAM,aAAa,KAAK,OAAO,GAAG;gBAElC,oEAAoE;gBACpE,iEAAiE;gBACjE,IAAI,SAAS,KAAK,WAAW,EAAE;oBAC3B,OAAO;wBACH,GAAG,IAAI;wBACP,IAAI,QAAQ,KAAK,WAAW;wBAC5B,OAAO,KAAK,KAAK,GAAG;wBACpB,aAAa,KAAK,KAAK,CAAC,KAAK,WAAW,GAAG;wBAC3C,SAAS;oBACb;gBACJ;gBAEA,OAAO;oBACH,GAAG,IAAI;oBACP,IAAI;oBACJ,SAAS;gBACb;YACJ;QACJ;QACA,mBAAmB,IAAA,sNAAM,EAAC;YACtB,MAAM,CAAC,EAAE,OAAO,EAAE;gBACd,+BAA+B;gBAC/B,MAAM,kBAAkB,IAAA,oJAAiB,EAAC;oBACtC,gBAAgB,QAAQ,IAAI,CAAC,cAAc;oBAC3C,cAAc,QAAQ,IAAI,CAAC,YAAY;oBACvC,OAAO,QAAQ,IAAI,CAAC,KAAK;oBACzB,SAAS,QAAQ,IAAI,CAAC,OAAO;oBAC7B,aAAa,QAAQ,IAAI,CAAC,WAAW;gBACzC,GAAG,QAAQ,IAAI,CAAC,YAAY;gBAE5B,IAAI,gBAAgB,MAAM,GAAG,GAAG;oBAC5B,OAAO;wBACH,GAAG,QAAQ,IAAI;wBACf,cAAc;+BAAI,QAAQ,IAAI,CAAC,YAAY;+BAAK,gBAAgB,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE;yBAAE;oBACnF;gBACJ;gBACA,OAAO,QAAQ,IAAI;YACvB;QACJ;IACJ;AACJ,GAAG,aAAa,CAAC;IACb,IAAI;IACJ,SAAS;IACT,SAAS;QACL,MAAM;QACN,YAAY;QACZ,WAAW;IACf;IACA,QAAQ;QACJ,MAAM;YACF,IAAI;gBACA,kBAAkB;oBACd,QAAQ;oBACR,SAAS,IAAA,sNAAM,EAAC;wBAAE,MAAM,CAAC,EAAE,KAAK,EAAE,GAAK,MAAM,IAAI;oBAAC;gBACtD;YACJ;QACJ;QACA,SAAS;YACL,QAAQ;QACZ;QACA,OAAO;YACH,IAAI;gBACA,iBAAiB;oBACb,SAAS;wBAAC;wBAAe;qBAAoB,CAAC,kBAAkB;gBACpE;gBACA,mBAAmB;oBACf,QAAQ;gBACZ;gBACA,uBAAuB;oBACnB,SAAS;gBACb;YACJ;QACJ;QACA,SAAS;YACL,IAAI;gBACA,qBAAqB;oBACjB,QAAQ;oBACR,SAAS,IAAA,sNAAM,EAAC;wBAAE,YAAY;oBAAS;gBAC3C;gBACA,qBAAqB;oBACjB,QAAQ;oBACR,SAAS,IAAA,sNAAM,EAAC;wBAAE,YAAY;wBAAS,WAAW,CAAC,EAAE,KAAK,EAAE,GAAK,MAAM,KAAK;oBAAC;gBACjF;YACJ;QACJ;IACJ;AACJ"}},
    {"offset": {"line": 728, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/machines/storyMachine.js"],"sourcesContent":["import { setup, assign } from 'xstate';\n\nexport const storyMachine = setup({\n    types: {\n        context: {},\n        events: {}\n    },\n    actions: {\n        setStories: assign({\n            stories: ({ event }) => event.stories\n        }),\n        addStory: assign({\n            stories: ({ context, event }) => [event.story, ...context.stories]\n        }),\n        removeStory: assign({\n            stories: ({ context, event }) => context.stories.filter(s => s.id !== event.id)\n        }),\n        updateStory: assign({\n            stories: ({ context, event }) => context.stories.map(s => s.id === event.story.id ? event.story : s)\n        })\n    }\n}).createMachine({\n    id: 'story',\n    initial: 'idle',\n    context: {\n        stories: [],\n        activeStoryId: null,\n        error: null\n    },\n    states: {\n        idle: {\n            on: {\n                'STORY.FETCH_START': 'fetching',\n                'STORY.CREATE_START': 'creating',\n                'STORY.DELETE': {\n                    actions: 'removeStory' // Optimistic update\n                    // We could add a 'deleting' state if we want to block UI, but usually optimistic is better\n                },\n                'STORY.SET_ACTIVE': {\n                    actions: assign({ activeStoryId: ({ event }) => event.id })\n                },\n                'STORY.REFINE_START': 'refining'\n            }\n        },\n        fetching: {\n            on: {\n                'STORY.FETCH_SUCCESS': {\n                    target: 'idle',\n                    actions: 'setStories'\n                },\n                'STORY.FETCH_FAILURE': {\n                    target: 'idle',\n                    actions: assign({ error: ({ event }) => event.error })\n                }\n            }\n        },\n        creating: {\n            on: {\n                'STORY.CREATE_SUCCESS': {\n                    target: 'idle',\n                    actions: 'addStory'\n                },\n                'STORY.CREATE_FAILURE': {\n                    target: 'idle',\n                    actions: assign({ error: ({ event }) => event.error })\n                }\n            }\n        },\n        refining: {\n            on: {\n                'STORY.REFINE_SUCCESS': {\n                    target: 'idle',\n                    actions: 'updateStory'\n                },\n                'STORY.REFINE_FAILURE': {\n                    target: 'idle',\n                    actions: assign({ error: ({ event }) => event.error })\n                }\n            }\n        }\n    }\n});\n"],"names":[],"mappings":";;;;AAAA;AAAA;;AAEO,MAAM,eAAe,IAAA,0LAAK,EAAC;IAC9B,OAAO;QACH,SAAS,CAAC;QACV,QAAQ,CAAC;IACb;IACA,SAAS;QACL,YAAY,IAAA,sNAAM,EAAC;YACf,SAAS,CAAC,EAAE,KAAK,EAAE,GAAK,MAAM,OAAO;QACzC;QACA,UAAU,IAAA,sNAAM,EAAC;YACb,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,GAAK;oBAAC,MAAM,KAAK;uBAAK,QAAQ,OAAO;iBAAC;QACtE;QACA,aAAa,IAAA,sNAAM,EAAC;YAChB,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,GAAK,QAAQ,OAAO,CAAC,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,MAAM,EAAE;QAClF;QACA,aAAa,IAAA,sNAAM,EAAC;YAChB,SAAS,CAAC,EAAE,OAAO,EAAE,KAAK,EAAE,GAAK,QAAQ,OAAO,CAAC,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,MAAM,KAAK,CAAC,EAAE,GAAG,MAAM,KAAK,GAAG;QACtG;IACJ;AACJ,GAAG,aAAa,CAAC;IACb,IAAI;IACJ,SAAS;IACT,SAAS;QACL,SAAS,EAAE;QACX,eAAe;QACf,OAAO;IACX;IACA,QAAQ;QACJ,MAAM;YACF,IAAI;gBACA,qBAAqB;gBACrB,sBAAsB;gBACtB,gBAAgB;oBACZ,SAAS,cAAc,oBAAoB;gBAE/C;gBACA,oBAAoB;oBAChB,SAAS,IAAA,sNAAM,EAAC;wBAAE,eAAe,CAAC,EAAE,KAAK,EAAE,GAAK,MAAM,EAAE;oBAAC;gBAC7D;gBACA,sBAAsB;YAC1B;QACJ;QACA,UAAU;YACN,IAAI;gBACA,uBAAuB;oBACnB,QAAQ;oBACR,SAAS;gBACb;gBACA,uBAAuB;oBACnB,QAAQ;oBACR,SAAS,IAAA,sNAAM,EAAC;wBAAE,OAAO,CAAC,EAAE,KAAK,EAAE,GAAK,MAAM,KAAK;oBAAC;gBACxD;YACJ;QACJ;QACA,UAAU;YACN,IAAI;gBACA,wBAAwB;oBACpB,QAAQ;oBACR,SAAS;gBACb;gBACA,wBAAwB;oBACpB,QAAQ;oBACR,SAAS,IAAA,sNAAM,EAAC;wBAAE,OAAO,CAAC,EAAE,KAAK,EAAE,GAAK,MAAM,KAAK;oBAAC;gBACxD;YACJ;QACJ;QACA,UAAU;YACN,IAAI;gBACA,wBAAwB;oBACpB,QAAQ;oBACR,SAAS;gBACb;gBACA,wBAAwB;oBACpB,QAAQ;oBACR,SAAS,IAAA,sNAAM,EAAC;wBAAE,OAAO,CAAC,EAAE,KAAK,EAAE,GAAK,MAAM,KAAK;oBAAC;gBACxD;YACJ;QACJ;IACJ;AACJ"}},
    {"offset": {"line": 832, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/machines/appMachine.js"],"sourcesContent":["import { setup } from 'xstate';\nimport { authMachine } from './authMachine';\nimport { userMachine } from './userMachine';\nimport { storyMachine } from './storyMachine';\n\nexport const appMachine = setup({\n    actors: {\n        authMachine,\n        userMachine,\n        storyMachine\n    }\n}).createMachine({\n    id: 'app',\n    type: 'parallel',\n    states: {\n        auth: {\n            invoke: {\n                id: 'auth',\n                src: 'authMachine'\n            }\n        },\n        user: {\n            invoke: {\n                id: 'user',\n                src: 'userMachine'\n            }\n        },\n        story: {\n            invoke: {\n                id: 'story',\n                src: 'storyMachine'\n            }\n        }\n    }\n});\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;AACA;;;;;AAEO,MAAM,aAAa,IAAA,0LAAK,EAAC;IAC5B,QAAQ;QACJ,aAAA,gJAAW;QACX,aAAA,gJAAW;QACX,cAAA,kJAAY;IAChB;AACJ,GAAG,aAAa,CAAC;IACb,IAAI;IACJ,MAAM;IACN,QAAQ;QACJ,MAAM;YACF,QAAQ;gBACJ,IAAI;gBACJ,KAAK;YACT;QACJ;QACA,MAAM;YACF,QAAQ;gBACJ,IAAI;gBACJ,KAAK;YACT;QACJ;QACA,OAAO;YACH,QAAQ;gBACJ,IAAI;gBACJ,KAAK;YACT;QACJ;IACJ;AACJ"}},
    {"offset": {"line": 881, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/context/GlobalStateMachineContext.jsx"],"sourcesContent":["'use client';\nimport React, { createContext, useContext } from 'react';\nimport { useMachine } from '@xstate/react';\nimport { appMachine } from '../machines/appMachine';\n\nconst GlobalStateMachineContext = createContext(null);\n\nexport const GlobalStateMachineProvider = ({ children }) => {\n    const [state, send, actor] = useMachine(appMachine);\n\n    // We expose the main actor. Components can subscribe to specific child actors using\n    // actor.getSnapshot().children.get('auth') etc., or we can provide helper hooks.\n\n    return (\n        <GlobalStateMachineContext.Provider value={{ actor }}>\n            {children}\n        </GlobalStateMachineContext.Provider>\n    );\n};\n\nexport const useGlobalMachine = () => {\n    const context = useContext(GlobalStateMachineContext);\n    if (!context) {\n        throw new Error('useGlobalMachine must be used within GlobalStateMachineProvider');\n    }\n    return context;\n};\n\n// Helper hooks for specific machines\nexport const useAuthActor = () => {\n    const { actor } = useGlobalMachine();\n    return actor.getSnapshot().children.auth;\n};\n\nexport const useUserActor = () => {\n    const { actor } = useGlobalMachine();\n    return actor.getSnapshot().children.user; // Note: 'user' is the invoke ID\n};\n\nexport const useStoryActor = () => {\n    const { actor } = useGlobalMachine();\n    return actor.getSnapshot().children.story;\n};\n"],"names":[],"mappings":";;;;;;;;;;;;;AACA;AACA;AACA;;;AAHA;;;;AAKA,MAAM,0CAA4B,IAAA,8KAAa,EAAC;AAEzC,MAAM,6BAA6B,CAAC,EAAE,QAAQ,EAAE;;IACnD,MAAM,CAAC,OAAO,MAAM,MAAM,GAAG,IAAA,mMAAU,EAAC,8IAAU;IAElD,oFAAoF;IACpF,iFAAiF;IAEjF,qBACI,6LAAC,0BAA0B,QAAQ;QAAC,OAAO;YAAE;QAAM;kBAC9C;;;;;;AAGb;GAXa;;QACoB,mMAAU;;;KAD9B;AAaN,MAAM,mBAAmB;;IAC5B,MAAM,UAAU,IAAA,2KAAU,EAAC;IAC3B,IAAI,CAAC,SAAS;QACV,MAAM,IAAI,MAAM;IACpB;IACA,OAAO;AACX;IANa;AASN,MAAM,eAAe;;IACxB,MAAM,EAAE,KAAK,EAAE,GAAG;IAClB,OAAO,MAAM,WAAW,GAAG,QAAQ,CAAC,IAAI;AAC5C;IAHa;;QACS;;;AAIf,MAAM,eAAe;;IACxB,MAAM,EAAE,KAAK,EAAE,GAAG;IAClB,OAAO,MAAM,WAAW,GAAG,QAAQ,CAAC,IAAI,EAAE,gCAAgC;AAC9E;IAHa;;QACS;;;AAIf,MAAM,gBAAgB;;IACzB,MAAM,EAAE,KAAK,EAAE,GAAG;IAClB,OAAO,MAAM,WAAW,GAAG,QAAQ,CAAC,KAAK;AAC7C;IAHa;;QACS"}},
    {"offset": {"line": 974, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/context/AuthContext.jsx"],"sourcesContent":["'use client';\nimport React, { createContext, useContext, useState, useEffect } from 'react';\nimport {\n    signInWithPopup,\n    GoogleAuthProvider,\n    GithubAuthProvider,\n    OAuthProvider,\n    createUserWithEmailAndPassword,\n    signInWithEmailAndPassword,\n    signOut as firebaseSignOut,\n    onAuthStateChanged\n} from 'firebase/auth';\nimport { googleAnalytics } from '../utils/googleAnalytics';\nimport { app, auth, db } from '../services/firebase';\n\nconst AuthContext = createContext(null);\n\n// Initialize Providers\nconst googleProvider = new GoogleAuthProvider();\nconst githubProvider = new GithubAuthProvider();\nconst microsoftProvider = new OAuthProvider('microsoft.com');\n\n// XState Imports\nimport { useAuthActor } from './GlobalStateMachineContext';\nimport { useSelector } from '@xstate/react';\n\nexport const AuthProvider = ({ children }) => {\n    // Connect to the Auth Machine\n    const authActor = useAuthActor();\n\n    // Selectors to get data from the machine\n    const user = useSelector(authActor, (snapshot) => snapshot.context.user);\n    const status = useSelector(authActor, (snapshot) => snapshot.value);\n    const loading = status === 'checking' || status === 'authenticating';\n\n    const [firebaseEnabled, setFirebaseEnabled] = useState(false);\n\n    useEffect(() => {\n        const enabled = !!app;\n        setFirebaseEnabled(enabled);\n\n        if (!enabled) {\n            // If Firebase is not enabled, we tell the machine we are done checking (with no user)\n            authActor.send({ type: 'AUTH.CHECK_COMPLETE', user: null });\n            return;\n        }\n\n        const unsubscribe = onAuthStateChanged(auth, (firebaseUser) => {\n            if (firebaseUser) {\n                const userData = {\n                    uid: firebaseUser.uid,\n                    email: firebaseUser.email,\n                    displayName: firebaseUser.displayName,\n                    photoURL: firebaseUser.photoURL\n                };\n\n                // Send event to machine\n                authActor.send({ type: 'AUTH.CHECK_COMPLETE', user: userData });\n\n                googleAnalytics.setUserProperties({\n                    user_id: firebaseUser.uid,\n                    user_email: firebaseUser.email\n                });\n            } else {\n                authActor.send({ type: 'AUTH.CHECK_COMPLETE', user: null });\n            }\n        });\n\n        return () => unsubscribe();\n    }, [authActor]);\n\n    const signInWithGoogle = async () => {\n        if (!firebaseEnabled) return { success: false, error: 'Authentication not configured' };\n\n        authActor.send({ type: 'AUTH.LOGIN_START' });\n\n        try {\n            const result = await signInWithPopup(auth, googleProvider);\n            const userData = {\n                uid: result.user.uid,\n                email: result.user.email,\n                displayName: result.user.displayName,\n                photoURL: result.user.photoURL\n            };\n\n            authActor.send({ type: 'AUTH.LOGIN_SUCCESS', user: userData });\n            googleAnalytics.trackEvent('user', 'sign_in', 'google');\n            return { success: true, user: result.user };\n        } catch (error) {\n            console.error('Google sign in failed:', error);\n            authActor.send({ type: 'AUTH.LOGIN_FAILURE', error: error.message });\n            return { success: false, error: error.message };\n        }\n    };\n\n    const signInWithGithub = async () => {\n        if (!firebaseEnabled) return { success: false, error: 'Authentication not configured' };\n\n        authActor.send({ type: 'AUTH.LOGIN_START' });\n\n        try {\n            const result = await signInWithPopup(auth, githubProvider);\n            const userData = {\n                uid: result.user.uid,\n                email: result.user.email,\n                displayName: result.user.displayName,\n                photoURL: result.user.photoURL\n            };\n\n            authActor.send({ type: 'AUTH.LOGIN_SUCCESS', user: userData });\n            googleAnalytics.trackEvent('user', 'sign_in', 'github');\n            return { success: true, user: result.user };\n        } catch (error) {\n            console.error('Github sign in failed:', error);\n            authActor.send({ type: 'AUTH.LOGIN_FAILURE', error: error.message });\n            return { success: false, error: error.message };\n        }\n    };\n\n    const signInWithMicrosoft = async () => {\n        if (!firebaseEnabled) return { success: false, error: 'Authentication not configured' };\n\n        authActor.send({ type: 'AUTH.LOGIN_START' });\n\n        try {\n            const result = await signInWithPopup(auth, microsoftProvider);\n            const userData = {\n                uid: result.user.uid,\n                email: result.user.email,\n                displayName: result.user.displayName,\n                photoURL: result.user.photoURL\n            };\n\n            authActor.send({ type: 'AUTH.LOGIN_SUCCESS', user: userData });\n            googleAnalytics.trackEvent('user', 'sign_in', 'microsoft');\n            return { success: true, user: result.user };\n        } catch (error) {\n            console.error('Microsoft sign in failed:', error);\n            authActor.send({ type: 'AUTH.LOGIN_FAILURE', error: error.message });\n            return { success: false, error: error.message };\n        }\n    };\n\n    const registerWithEmail = async (email, password) => {\n        if (!firebaseEnabled) return { success: false, error: 'Authentication not configured' };\n\n        authActor.send({ type: 'AUTH.LOGIN_START' });\n\n        try {\n            const result = await createUserWithEmailAndPassword(auth, email, password);\n            const userData = {\n                uid: result.user.uid,\n                email: result.user.email,\n                displayName: result.user.displayName,\n                photoURL: result.user.photoURL\n            };\n\n            authActor.send({ type: 'AUTH.LOGIN_SUCCESS', user: userData });\n            googleAnalytics.trackEvent('user', 'register', 'email');\n            return { success: true, user: result.user };\n        } catch (error) {\n            console.error('Registration failed:', error);\n            authActor.send({ type: 'AUTH.LOGIN_FAILURE', error: error.message });\n            return { success: false, error: error.message };\n        }\n    };\n\n    const signInWithEmail = async (email, password) => {\n        if (!firebaseEnabled) return { success: false, error: 'Authentication not configured' };\n\n        authActor.send({ type: 'AUTH.LOGIN_START' });\n\n        try {\n            const result = await signInWithEmailAndPassword(auth, email, password);\n            const userData = {\n                uid: result.user.uid,\n                email: result.user.email,\n                displayName: result.user.displayName,\n                photoURL: result.user.photoURL\n            };\n\n            authActor.send({ type: 'AUTH.LOGIN_SUCCESS', user: userData });\n            googleAnalytics.trackEvent('user', 'sign_in', 'email');\n            return { success: true, user: result.user };\n        } catch (error) {\n            console.error('Login failed:', error);\n            authActor.send({ type: 'AUTH.LOGIN_FAILURE', error: error.message });\n            return { success: false, error: error.message };\n        }\n    };\n\n    const signOut = async () => {\n        if (!firebaseEnabled) return;\n\n        authActor.send({ type: 'AUTH.LOGOUT_START' });\n\n        try {\n            await firebaseSignOut(auth);\n            // The onAuthStateChanged listener will fire and handle the rest (AUTH.CHECK_COMPLETE -> user: null)\n            // But we can also be explicit if we want:\n            // authActor.send({ type: 'AUTH.CHECK_COMPLETE', user: null });\n\n            googleAnalytics.trackEvent('user', 'sign_out', 'manual');\n            return { success: true };\n        } catch (error) {\n            console.error('Sign out failed:', error);\n            return { success: false, error: error.message };\n        }\n    };\n\n    const ADMIN_EMAIL = 'oguzhanacar.bt@gmail.com';\n\n    const value = React.useMemo(() => ({\n        user,\n        isAdmin: user?.email === ADMIN_EMAIL,\n        loading,\n        firebaseEnabled,\n        firestoreEnabled: !!db,\n        signInWithGoogle,\n        signInWithGithub,\n        signInWithMicrosoft,\n        registerWithEmail,\n        signInWithEmail,\n        signOut\n    }), [\n        user,\n        loading,\n        firebaseEnabled,\n        signInWithGoogle,\n        signInWithGithub,\n        signInWithMicrosoft,\n        registerWithEmail,\n        signInWithEmail,\n        signOut\n    ]);\n\n    return (\n        <AuthContext.Provider value={value}>\n            {children}\n        </AuthContext.Provider>\n    );\n};\n\nexport const useAuth = () => {\n    const context = useContext(AuthContext);\n    if (!context) {\n        throw new Error('useAuth must be used within AuthProvider');\n    }\n    return context;\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1329, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/services/firestoreService.js"],"sourcesContent":["import { doc, setDoc, getDoc, updateDoc, deleteDoc, collection, query, orderBy, limit, startAfter, getDocs, onSnapshot, serverTimestamp, writeBatch, increment } from 'firebase/firestore';\nimport { db } from './firebase';\n\n// Remove the initialize function as we now import db directly\n// export const initializeFirestore = (app) => { ... } is no longer needed\nconst DEFAULT_USER = {\n    xp: 0,\n    level: 1,\n    nextLevelXp: 1000,\n    title: \"Empati Ã‡Ä±raÄŸÄ±\"\n};\n\n// ==================== USER PROFILE ====================\n\nexport const getUserProfile = async (userId) => {\n    if (!db) throw new Error('Firestore not initialized');\n\n    try {\n        const docRef = doc(db, 'users', userId, 'data', 'profile');\n        const docSnap = await getDoc(docRef);\n\n        if (docSnap.exists()) {\n            return docSnap.data();\n        }\n        return null;\n    } catch (error) {\n        console.error('Error getting user profile:', error);\n        throw error;\n    }\n};\n\nexport const createUserProfile = async (userId, profileData) => {\n    if (!db) throw new Error('Firestore not initialized');\n\n    try {\n        const docRef = doc(db, 'users', userId, 'data', 'profile');\n        const data = {\n            ...profileData,\n            createdAt: serverTimestamp(),\n            updatedAt: serverTimestamp()\n        };\n\n        await setDoc(docRef, data);\n        return data;\n    } catch (error) {\n        console.error('Error creating user profile:', error);\n        throw error;\n    }\n};\n\n// ==================== WRITE BUFFERING (SCALE HARDENING) ====================\nconst profileBuffer = new Map();\nlet syncTimeout = null;\nconst SYNC_DEBOUNCE_MS = 2000;\n\nconst commitProfileSync = async (userId) => {\n    if (!profileBuffer.has(userId) || !db) return;\n\n    const data = profileBuffer.get(userId);\n    profileBuffer.delete(userId);\n\n    try {\n        const docRef = doc(db, 'users', userId, 'data', 'profile');\n        await updateDoc(docRef, {\n            ...data,\n            updatedAt: serverTimestamp()\n        });\n        console.log(`â˜ï¸ Cloud Sync: Profile updated for ${userId}`);\n    } catch (error) {\n        console.error('Buffer Sync Error:', error);\n        // Put back in buffer on failure to retry\n        profileBuffer.set(userId, { ...data, ...profileBuffer.get(userId) });\n    }\n};\n\nexport const updateUserProfile = async (userId, updates) => {\n    if (!db) throw new Error('Firestore not initialized');\n\n    // Add to buffer\n    const current = profileBuffer.get(userId) || {};\n    profileBuffer.set(userId, { ...current, ...updates });\n\n    // Debounce commit\n    if (syncTimeout) clearTimeout(syncTimeout);\n    syncTimeout = setTimeout(() => commitProfileSync(userId), SYNC_DEBOUNCE_MS);\n\n    return { ...current, ...updates, buffered: true };\n};\n\n// ==================== STORIES ====================\n\nexport const getUserStories = async (userId) => {\n    if (!db) throw new Error('Firestore not initialized');\n\n    try {\n        const storiesRef = collection(db, 'users', userId, 'stories');\n        const q = query(storiesRef, orderBy('createdAt', 'desc'));\n\n        return new Promise((resolve, reject) => {\n            const unsubscribe = onSnapshot(q,\n                (snapshot) => {\n                    const stories = [];\n                    snapshot.forEach((doc) => {\n                        stories.push({ id: doc.id, ...doc.data() });\n                    });\n                    unsubscribe();\n                    resolve(stories);\n                },\n                (error) => {\n                    unsubscribe();\n                    reject(error);\n                }\n            );\n        });\n    } catch (error) {\n        console.error('Error getting user stories:', error);\n        throw error;\n    }\n};\n\nexport const saveStory = async (userId, story) => {\n    if (!db) throw new Error('Firestore not initialized');\n\n    try {\n        const storyId = String(story.id || Date.now());\n        const docRef = doc(db, 'users', userId, 'stories', storyId);\n\n        const data = {\n            ...story,\n            id: storyId,\n            createdAt: story.createdAt || serverTimestamp(),\n            updatedAt: serverTimestamp()\n        };\n\n        await setDoc(docRef, data);\n        return { ...data, id: storyId };\n    } catch (error) {\n        console.error('Error saving story:', error);\n        throw error;\n    }\n};\n\nexport const deleteStory = async (userId, storyId) => {\n    if (!db) throw new Error('Firestore not initialized');\n\n    try {\n        const docRef = doc(db, 'users', userId, 'stories', String(storyId));\n        await deleteDoc(docRef);\n    } catch (error) {\n        console.error('Error deleting story:', error);\n        throw error;\n    }\n};\n\n// ==================== REAL-TIME SYNC ====================\n\nexport const subscribeToProfile = (userId, callback) => {\n    if (!db) {\n        console.warn('Firestore not initialized, skipping subscription');\n        return () => { };\n    }\n\n    try {\n        const docRef = doc(db, 'users', userId, 'data', 'profile');\n\n        const unsubscribe = onSnapshot(docRef,\n            (doc) => {\n                if (doc.exists()) {\n                    callback(doc.data());\n                }\n            },\n            (error) => {\n                console.error('Error in profile subscription:', error);\n            }\n        );\n\n        return unsubscribe;\n    } catch (error) {\n        console.error('Error subscribing to profile:', error);\n        return () => { };\n    }\n};\n\nexport const subscribeToStories = (userId, callback) => {\n    if (!db) {\n        console.warn('Firestore not initialized, skipping subscription');\n        return () => { };\n    }\n\n    try {\n        const storiesRef = collection(db, 'users', userId, 'stories');\n        const q = query(storiesRef, orderBy('createdAt', 'desc'));\n\n        const unsubscribe = onSnapshot(q,\n            (snapshot) => {\n                const stories = [];\n                snapshot.forEach((doc) => {\n                    stories.push({ id: doc.id, ...doc.data() });\n                });\n                callback(stories);\n            },\n            (error) => {\n                console.error('Error in stories subscription:', error);\n            }\n        );\n\n        return unsubscribe;\n    } catch (error) {\n        console.error('Error subscribing to stories:', error);\n        return () => { };\n    }\n};\n\n// ==================== BATCH OPERATIONS ====================\n\nexport const batchSaveStories = async (userId, stories) => {\n    if (!db) throw new Error('Firestore not initialized');\n\n    try {\n        const batch = writeBatch(db);\n\n        stories.forEach((story) => {\n            const storyId = String(story.id || (Date.now() + Math.random()));\n            const docRef = doc(db, 'users', userId, 'stories', storyId);\n\n            batch.set(docRef, {\n                ...story,\n                id: storyId,\n                createdAt: story.createdAt || serverTimestamp(),\n                updatedAt: serverTimestamp()\n            });\n        });\n\n        await batch.commit();\n        console.log(`âœ… Batch saved ${stories.length} stories to cloud`);\n    } catch (error) {\n        console.error('Error batch saving stories:', error);\n        throw error;\n    }\n};\n\n// ==================== COMMUNITY / PUBLIC FEED ====================\n\nexport const createPublicPost = async (userId, authorData, content, type = 'text', additionalData = null) => {\n    if (!db) throw new Error('Firestore not initialized');\n\n    try {\n        const postsRef = collection(db, 'community');\n        const newPostRef = doc(postsRef);\n\n        const postData = {\n            id: newPostRef.id,\n            authorId: userId,\n            authorName: authorData.displayName || 'Anonim Koza',\n            authorAvatar: authorData.avatarUrl || '',\n            content,\n            type,\n            data: additionalData,\n            createdAt: serverTimestamp(),\n            likesCount: 0,\n            repliesCount: 0,\n            tags: extractTags(content)\n        };\n\n        await setDoc(newPostRef, postData);\n        return postData;\n    } catch (error) {\n        console.error('Error creating public post:', error);\n        throw error;\n    }\n};\n\nexport const getPublicFeed = async (activeTab = 'local', lastDoc = null, limitCount = 20) => {\n    if (!db) throw new Error('Firestore not initialized');\n\n    try {\n        const postsRef = collection(db, 'community');\n        let q;\n\n        if (activeTab === 'local' || activeTab === 'all') {\n            q = query(postsRef, orderBy('createdAt', 'desc'), limit(limitCount));\n        } else {\n            const tag = activeTab.startsWith('#') ? activeTab : `#${activeTab}`;\n            q = query(postsRef, orderBy('createdAt', 'desc'), limit(limitCount));\n            // Note: In Firestore, filtering by tags usually requires array-contains or a separate structure.\n            // For now, we'll do basic global feed or specific tag if we implement it.\n            // Let's assume tags are handled via array-contains.\n            // q = query(postsRef, where('tags', 'array-contains', tag), orderBy('createdAt', 'desc'), limit(limitCount));\n        }\n\n        if (lastDoc) {\n            q = query(q, startAfter(lastDoc));\n        }\n\n        const snapshot = await getDocs(q);\n        const posts = [];\n        snapshot.forEach(doc => {\n            posts.push({ id: doc.id, ...doc.data() });\n        });\n\n        return {\n            posts,\n            lastDoc: snapshot.docs[snapshot.docs.length - 1] || null\n        };\n    } catch (error) {\n        console.error('Error getting public feed:', error);\n        throw error;\n    }\n};\n\nexport const likePost = async (postId) => {\n    if (!db) throw new Error('Firestore not initialized');\n    try {\n        const postRef = doc(db, 'community', postId);\n        await updateDoc(postRef, {\n            likesCount: increment(1)\n        });\n    } catch (error) {\n        console.error('Error liking post:', error);\n    }\n};\n\nexport const subscribeToNotifications = (userId, callback) => {\n    if (!db) return () => { };\n    try {\n        const notifsRef = collection(db, 'users', userId, 'notifications');\n        const q = query(notifsRef, orderBy('createdAt', 'desc'), limit(20));\n\n        return onSnapshot(q, (snapshot) => {\n            const notifs = [];\n            snapshot.forEach(doc => {\n                notifs.push({ id: doc.id, ...doc.data() });\n            });\n            callback(notifs);\n        });\n    } catch (error) {\n        console.error('Error subscribing to notifications:', error);\n        return () => { };\n    }\n};\n\nconst extractTags = (text) => {\n    if (!text) return [];\n    const tags = text.match(/#\\w+/g);\n    return tags ? tags.map(t => t.toLowerCase()) : [];\n};\n\n// ==================== SYNC HELPERS ====================\n\nexport const syncLocalToCloud = async (userId, localData) => {\n    if (!db) {\n        console.warn('Firestore not initialized, skipping cloud sync');\n        return null;\n    }\n\n    try {\n        // 1. Get existing cloud profile\n        const cloudProfile = await getUserProfile(userId);\n        let profileToUse = cloudProfile;\n\n        // 2. Migration Gap Fix: Always attempt to push local stories to cloud\n        // Using batchSaveStories is safe because it uses setDoc which is idempotent\n        if (localData.stories && localData.stories.length > 0) {\n            console.log(`ðŸ“¤ Syncing ${localData.stories.length} local stories to cloud...`);\n            await batchSaveStories(userId, localData.stories);\n        }\n\n        if (!cloudProfile) {\n            // First time sign in - Create profile from local stats\n            console.log('ðŸ“¤ Creating initial cloud profile for user:', userId);\n\n            profileToUse = {\n                xp: localData.user?.xp || DEFAULT_USER.xp,\n                level: localData.user?.level || DEFAULT_USER.level,\n                nextLevelXp: localData.user?.nextLevelXp || DEFAULT_USER.nextLevelXp,\n                totalXP: localData.user?.totalXP || localData.user?.xp || DEFAULT_USER.xp,\n                storiesCreated: localData.user?.storiesCreated || 0,\n                gamesCreated: localData.user?.gamesCreated || 0,\n                storiesRead: localData.user?.storiesRead || 0,\n                gamesPlayed: localData.user?.gamesPlayed || 0,\n                dailyStreak: localData.user?.dailyStreak || 0,\n                lastVisit: localData.user?.lastVisit || new Date().toISOString(),\n                title: localData.user?.title || DEFAULT_USER.title,\n                achievements: localData.user?.achievements || [],\n                badges: localData.user?.badges || []\n            };\n\n            await createUserProfile(userId, profileToUse);\n            console.log('âœ… Migration complete');\n            return { migrated: true, profile: profileToUse };\n        } else {\n            // Merging: For now Cloud Profile wins on stats, but stories were merged above\n            console.log('ðŸ”„ Profile exists in cloud, prioritizing cloud stats');\n            return { migrated: false, profile: cloudProfile };\n        }\n    } catch (error) {\n        console.error('Error in syncLocalToCloud:', error);\n        throw error;\n    }\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1722, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/utils/analytics.js"],"sourcesContent":["/**\n * Analytics and tracking utilities\n */\n\nimport { googleAnalytics } from './googleAnalytics';\n\nclass Analytics {\n    constructor() {\n        this.events = [];\n        this.sessionStart = Date.now();\n    }\n\n    track(eventName, properties = {}) {\n        const event = {\n            name: eventName,\n            timestamp: Date.now(),\n            sessionDuration: Date.now() - this.sessionStart,\n            ...properties\n        };\n\n        this.events.push(event);\n\n        // Store in localStorage for persistence\n        this.saveToStorage();\n\n        // Send to Google Analytics\n        googleAnalytics.trackEvent(\n            'app_interaction',\n            eventName,\n            properties.label || '',\n            properties.value || undefined\n        );\n\n        console.log('ðŸ“Š Analytics:', eventName, properties);\n    }\n\n    saveToStorage() {\n        try {\n            const stored = JSON.parse(localStorage.getItem('koza-analytics') || '[]');\n            const combined = [...stored, ...this.events].slice(-100); // Keep last 100 events\n            localStorage.setItem('koza-analytics', JSON.stringify(combined));\n            this.events = [];\n        } catch (e) {\n            console.error('Failed to save analytics:', e);\n        }\n    }\n\n    getStats() {\n        try {\n            const events = JSON.parse(localStorage.getItem('koza-analytics') || '[]');\n            return {\n                totalEvents: events.length,\n                storiesCreated: events.filter(e => e.name === 'story_created').length,\n                gamesCreated: events.filter(e => e.name === 'game_created').length,\n                xpEarned: events\n                    .filter(e => e.name === 'xp_awarded')\n                    .reduce((sum, e) => sum + (e.amount || 0), 0),\n                lastActivity: events.length > 0 ? events[events.length - 1].timestamp : null\n            };\n        } catch {\n            return null;\n        }\n    }\n}\n\nexport const analytics = new Analytics();\n"],"names":[],"mappings":";;;;AAAA;;CAEC,GAED;;AAEA,MAAM;IACF,aAAc;QACV,IAAI,CAAC,MAAM,GAAG,EAAE;QAChB,IAAI,CAAC,YAAY,GAAG,KAAK,GAAG;IAChC;IAEA,MAAM,SAAS,EAAE,aAAa,CAAC,CAAC,EAAE;QAC9B,MAAM,QAAQ;YACV,MAAM;YACN,WAAW,KAAK,GAAG;YACnB,iBAAiB,KAAK,GAAG,KAAK,IAAI,CAAC,YAAY;YAC/C,GAAG,UAAU;QACjB;QAEA,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC;QAEjB,wCAAwC;QACxC,IAAI,CAAC,aAAa;QAElB,2BAA2B;QAC3B,qJAAe,CAAC,UAAU,CACtB,mBACA,WACA,WAAW,KAAK,IAAI,IACpB,WAAW,KAAK,IAAI;QAGxB,QAAQ,GAAG,CAAC,iBAAiB,WAAW;IAC5C;IAEA,gBAAgB;QACZ,IAAI;YACA,MAAM,SAAS,KAAK,KAAK,CAAC,aAAa,OAAO,CAAC,qBAAqB;YACpE,MAAM,WAAW;mBAAI;mBAAW,IAAI,CAAC,MAAM;aAAC,CAAC,KAAK,CAAC,CAAC,MAAM,uBAAuB;YACjF,aAAa,OAAO,CAAC,kBAAkB,KAAK,SAAS,CAAC;YACtD,IAAI,CAAC,MAAM,GAAG,EAAE;QACpB,EAAE,OAAO,GAAG;YACR,QAAQ,KAAK,CAAC,6BAA6B;QAC/C;IACJ;IAEA,WAAW;QACP,IAAI;YACA,MAAM,SAAS,KAAK,KAAK,CAAC,aAAa,OAAO,CAAC,qBAAqB;YACpE,OAAO;gBACH,aAAa,OAAO,MAAM;gBAC1B,gBAAgB,OAAO,MAAM,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK,iBAAiB,MAAM;gBACrE,cAAc,OAAO,MAAM,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK,gBAAgB,MAAM;gBAClE,UAAU,OACL,MAAM,CAAC,CAAA,IAAK,EAAE,IAAI,KAAK,cACvB,MAAM,CAAC,CAAC,KAAK,IAAM,MAAM,CAAC,EAAE,MAAM,IAAI,CAAC,GAAG;gBAC/C,cAAc,OAAO,MAAM,GAAG,IAAI,MAAM,CAAC,OAAO,MAAM,GAAG,EAAE,CAAC,SAAS,GAAG;YAC5E;QACJ,EAAE,OAAM;YACJ,OAAO;QACX;IACJ;AACJ;AAEO,MAAM,YAAY,IAAI"}},
    {"offset": {"line": 1785, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/context/UserContext.jsx"],"sourcesContent":["'use client';\nimport React, { createContext, useContext, useEffect, useState, useCallback } from 'react';\nimport useLocalStorage from '../hooks/useLocalStorage';\nimport { useAuth } from './AuthContext';\nimport * as firestoreService from '../services/firestoreService';\nimport { analytics } from '../utils/analytics';\nimport { checkAchievements } from '../utils/achievements';\n\nconst UserContext = createContext(null);\n\nconst DEFAULT_USER = {\n    xp: 850,\n    level: 1,\n    nextLevelXp: 1000,\n    storiesRead: 3,\n    gamesPlayed: 1,\n    storiesCreated: 0,\n    gamesCreated: 0,\n    totalXP: 850,\n    dailyStreak: 0,\n    lastVisit: null,\n    title: \"Empati Ã‡Ä±raÄŸÄ±\",\n    badges: [\n        { id: 1, name: \"Ä°lk AdÄ±m\", unlocked: true },\n        { id: 2, name: \"Hikaye AnlatÄ±cÄ±sÄ±\", unlocked: false },\n        { id: 3, name: \"Topluluk YÄ±ldÄ±zÄ±\", unlocked: false },\n    ],\n    achievements: []\n};\n\n// XState Imports\nimport { useUserActor } from './GlobalStateMachineContext';\nimport { useSelector } from '@xstate/react';\n\nexport const UserProvider = ({ children }) => {\n    const { user: authUser, firestoreEnabled } = useAuth();\n\n    // Connect to User Machine\n    const userActor = useUserActor();\n    const user = useSelector(userActor, (snapshot) => snapshot.context.user);\n    const syncStatus = useSelector(userActor, (snapshot) => snapshot.context.syncStatus);\n    const isSyncing = syncStatus === 'syncing';\n    const cloudSynced = syncStatus === 'synced'; // or check specific state matching\n\n    // Local Storage Sync (Manual implementation to replace useLocalStorage hook's auto-write)\n    const [storedUser, setStoredUser] = useLocalStorage('koza-user', DEFAULT_USER);\n\n    // Initial Load\n    useEffect(() => {\n        if (storedUser) {\n            userActor.send({ type: 'USER.LOAD_DATA', data: storedUser });\n        }\n    }, []); // Run once on mount\n\n    // Persist machine state to local storage\n    useEffect(() => {\n        if (user) {\n            setStoredUser(user);\n        }\n    }, [user, setStoredUser]);\n\n    // We keep lastUserEvent for the AppContextBridge to pick up (Toast notifications)\n    // We can detect changes in user.level or user.achievements to set this.\n    // However, the machine handles the logic. \n    // Optimization: logic from 'userMachine' is pure, but we need to know *when* an event happened.\n    // We can listen to the actor's event stream.\n    const [lastUserEvent, setLastUserEvent] = useState(null);\n\n    useEffect(() => {\n        const subscription = userActor.on('USER.AWARD_XP', (event) => {\n            // This listener might not be supported on the actor ref directly in all versions, \n            // but 'actor.subscribe' gives us state changes. \n            // Inspection API is better. For now, let's use the diffing approach for simplicity and robustness.\n        });\n        return () => {\n            if (subscription && typeof subscription.unsubscribe === 'function') subscription.unsubscribe();\n        };\n    }, [userActor]);\n\n    // Simple Diffing for Notifications (Robust fallback)\n    const [prevUser, setPrevUser] = useState(user);\n\n    useEffect(() => {\n        if (!user || !prevUser) {\n            setPrevUser(user);\n            return;\n        }\n\n        if (user.level > prevUser.level) {\n            setLastUserEvent({ type: 'levelup', level: user.level });\n        } else if (user.xp > prevUser.xp) {\n            const diff = user.xp - prevUser.xp;\n            if (diff > 0) {\n                // We don't have the 'reason' here easily unless we store it in machine context \n                // or listen to the event. For now, generic reason or passed via a side-channel?\n                // Actually, we can just say \"XP KazanÄ±ldÄ±\".\n                setLastUserEvent({ type: 'xp', amount: diff, reason: \"BaÅŸarÄ±m\" });\n            }\n        }\n\n        if (user.achievements.length > prevUser.achievements.length) {\n            // Find new achievements\n            const newIds = user.achievements.filter(id => !prevUser.achievements.includes(id));\n            // We need to map IDs to objects. We'll need the checkAchievements utility or specific list.\n            // For now, let's assume we can fetch metadata elsewhere or just notify generic.\n            // But AppContextBridge expects 'achievements' array.\n            // Let's reload achievements metadata? \n            // Ideally the machine event `USER.AWARD_XP` could carry the result, but machines are pure.\n\n            // Quick fix: allow LastUserEvent to be set by the awardXP wrapper too?\n            // No, let's stick to state diffing.\n            const newAch = newIds.map(id => ({ id, name: \"Yeni BaÅŸarÄ±m\", icon: \"ðŸ†\" })); // Placeholder\n            setLastUserEvent({ type: 'achievement', achievements: newAch });\n        }\n\n        setPrevUser(user);\n    }, [user]);\n\n    // Track daily streak\n    useEffect(() => {\n        const today = new Date().toDateString();\n        // Safety check: if user is null (cleared storage but not context), skip\n        if (!user) return;\n        const lastVisit = user.lastVisit;\n\n        if (lastVisit !== today) {\n            const yesterday = new Date();\n            yesterday.setDate(yesterday.getDate() - 1);\n            const yesterdayStr = yesterday.toDateString();\n\n            const newStreak = lastVisit === yesterdayStr ? user.dailyStreak + 1 : 1;\n\n            userActor.send({\n                type: 'USER.UPDATE_PROFILE',\n                data: { lastVisit: today, dailyStreak: newStreak }\n            });\n        }\n    }, [user?.lastVisit, userActor]); // Depend on lastVisit to avoid loops, but need to be careful.\n    // Actually, if we update user, user changes, effect runs again?\n    // user.lastVisit will be today after update. 'today' will be same. Condition `lastVisit !== today` will be false. Safe.\n\n    // Sync with Firestore\n    useEffect(() => {\n        if (!authUser || !firestoreEnabled || cloudSynced) return;\n\n        // Trigger Sync in machine\n        userActor.send({ type: 'USER.SYNC_START' });\n\n        const syncData = async () => {\n            try {\n                console.log('ðŸ”„ User: Initiating full cloud synchronization...');\n                const localStories = JSON.parse(localStorage.getItem('koza-stories') || '[]');\n\n                // We pass 'user' from the machine state (which is loaded from localStorage initially)\n                const currentLocalUser = user || storedUser;\n\n                const syncResult = await firestoreService.syncLocalToCloud(authUser.uid, {\n                    user: currentLocalUser,\n                    stories: localStories\n                });\n\n                if (syncResult && syncResult.profile) {\n                    // Update machine with cloud data\n                    userActor.send({ type: 'USER.UPDATE_PROFILE', data: syncResult.profile });\n                    userActor.send({ type: 'USER.SYNC_SUCCESS' });\n\n                    if (syncResult.migrated) {\n                        console.log('âœ… Local data successfully migrated to cloud');\n                    }\n                } else {\n                    userActor.send({ type: 'USER.SYNC_SUCCESS' }); // Even if no changes, we synced.\n                }\n            } catch (error) {\n                console.error('User Sync error:', error);\n                userActor.send({ type: 'USER.SYNC_FAILURE', error: error.message });\n            }\n        };\n\n        syncData();\n    }, [authUser, firestoreEnabled, cloudSynced, userActor]);\n\n    // Real-time Updates\n    useEffect(() => {\n        if (!authUser || !firestoreEnabled || !cloudSynced) return;\n        const unsubscribe = firestoreService.subscribeToProfile(authUser.uid, (data) => {\n            if (data) {\n                userActor.send({ type: 'USER.UPDATE_PROFILE', data });\n            }\n        });\n        return () => unsubscribe();\n    }, [authUser, firestoreEnabled, cloudSynced, userActor]);\n\n    // Debounced Sync to Firestore (Background Save)\n    useEffect(() => {\n        if (!authUser || !firestoreEnabled || !cloudSynced || !user) return;\n\n        const syncTimer = setTimeout(() => {\n            firestoreService.updateUserProfile(authUser.uid, {\n                xp: user.xp,\n                level: user.level,\n                nextLevelXp: user.nextLevelXp,\n                totalXP: user.totalXP,\n                storiesCreated: user.storiesCreated,\n                gamesCreated: user.gamesCreated,\n                storiesRead: user.storiesRead,\n                gamesPlayed: user.gamesPlayed,\n                dailyStreak: user.dailyStreak,\n                lastVisit: user.lastVisit,\n                title: user.title,\n                achievements: user.achievements,\n                badges: user.badges\n            }).catch(e => console.error(\"Background sync error:\", e));\n        }, 2000);\n\n        return () => clearTimeout(syncTimer);\n    }, [user, authUser, firestoreEnabled, cloudSynced]);\n\n    const awardXP = useCallback((amount, reason) => {\n        analytics.track('xp_awarded', { amount, reason });\n\n        // Store reason temporarily for the diff effect? \n        // Or just fire and forget. The diff effect will catch the XP change.\n        userActor.send({ type: 'USER.AWARD_XP', amount });\n\n        // Manual override for reason tracking if needed for toast\n        // We could set a short-lived state here?\n        // But AppContextBridge relies on 'lastUserEvent'. \n        // Let's set it here explicitly for the 'reason' context.\n        // But wait, if we set it here, and also the diff effect sets it...\n        // Let's trust the diff effect for now, or improve it later.\n        // Actually, to get the \"Reason\" into the Toast, we need it.\n        // Simple hack: \n        setLastUserEvent({ type: 'xp', amount, reason });\n\n    }, [userActor]);\n\n    /* \n       Direct setter replacement. \n       components calling setUser(newData) or setUser(prev => ...)\n       We need to support functional updates if we want full compatibility.\n    */\n    const setUser = useCallback((update) => {\n        let newData;\n        if (typeof update === 'function') {\n            // This is dangerous if we don't have current 'user'. \n            // We can read 'user' from the closure, but it might be stale?\n            // useSelector 'user' is the latest render value.\n            // XState doesn't support \"updater functions\" in events directly usually.\n            // We'll calculate it here.\n            // CAUTION: 'user' dependency might cause re-creation of setUser, \n            // but that's standard React.\n            // We can use actor.getSnapshot().context.user to be safe?\n            const currentUser = userActor.getSnapshot().context.user || DEFAULT_USER;\n            newData = update(currentUser);\n        } else {\n            newData = update;\n        }\n\n        userActor.send({ type: 'USER.UPDATE_PROFILE', data: newData });\n    }, [userActor]);\n\n    const value = React.useMemo(() => ({\n        user,\n        setUser,\n        awardXP,\n        isSyncing,\n        cloudSynced,\n        lastUserEvent,\n        setLastUserEvent\n    }), [\n        user,\n        setUser,\n        awardXP,\n        isSyncing,\n        cloudSynced,\n        lastUserEvent,\n        setLastUserEvent\n    ]);\n\n    return <UserContext.Provider value={value}>{children}</UserContext.Provider>;\n\n    // Note: The original returned children wrapped in provider. \n    // We are doing the same.\n};\n\nexport const useUser = () => {\n    const context = useContext(UserContext);\n    if (!context) throw new Error('useUser must be used within UserProvider');\n    return context;\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2213, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/context/StoryContext.jsx"],"sourcesContent":["'use client';\nimport React, { createContext, useContext, useEffect, useState, useCallback } from 'react';\nimport useLocalStorage from '../hooks/useLocalStorage';\nimport { useAuth } from './AuthContext';\nimport { useUser } from './UserContext'; // We might need to update user stats on story save\nimport * as firestoreService from '../services/firestoreService';\nimport { analytics } from '../utils/analytics';\n\nconst StoryContext = createContext(null);\n\nconst COMMUNITY_WORKS = [\n    // TODO: Connect to 'community' collection in Firestore\n    // {\n    //     id: 1,\n    //     title: \"Sessiz Ã‡Ä±ÄŸlÄ±ÄŸÄ±n DÃ¶nÃ¼ÅŸÃ¼mÃ¼\",\n    //     ...\n    // }\n];\n\n// XState Imports\nimport { useStoryActor } from './GlobalStateMachineContext';\nimport { useSelector } from '@xstate/react';\n\nexport const StoryProvider = ({ children }) => {\n    const { user: authUser, firestoreEnabled } = useAuth();\n    const { cloudSynced } = useUser(); // We might depend on user being synced?\n\n    // Connect to Story Machine\n    const storyActor = useStoryActor();\n    const savedStories = useSelector(storyActor, (snapshot) => snapshot.context.stories);\n\n    // We keep 'activeStory' (the draft) in local state for performance (avoiding machine transition on every keystroke)\n    const [activeStory, setActiveStory] = useState('');\n    const [isProcessing, setIsProcessing] = useState(false);\n    const [analysisResult, setAnalysisResult] = useState(null);\n    const [lastSavedStory, setLastSavedStory] = useState(null);\n\n    // Local Storage Sync (Manual implementation)\n    const [localStories, setLocalStories] = useLocalStorage('koza-stories', []);\n\n    // Initial Load\n    useEffect(() => {\n        if (localStories && localStories.length > 0) {\n            // If machine is empty, load from local\n            // We can check if machine has stories? \n            // Ideally machine is SOT. \n            storyActor.send({ type: 'STORY.FETCH_SUCCESS', stories: localStories });\n        }\n    }, []); // Run once\n\n    // Persist machine state to local storage\n    useEffect(() => {\n        setLocalStories(savedStories);\n    }, [savedStories, setLocalStories]);\n\n\n    // Load/Sync Stories from Cloud\n    useEffect(() => {\n        if (!authUser || !firestoreEnabled || !cloudSynced) return;\n\n        storyActor.send({ type: 'STORY.FETCH_START' });\n\n        const loadStories = async () => {\n            try {\n                const cloudStories = await firestoreService.getUserStories(authUser.uid);\n                if (cloudStories) {\n                    // Merge strategy?\n                    // Current strategy in old Context was: map merge.\n                    // We should prob do the merge here and send SET matches.\n                    // Or just trust cloud? \n                    // Let's do the merge to be safe and robust.\n                    const mergedMap = new Map();\n                    savedStories.forEach(s => mergedMap.set(String(s.id), s));\n                    cloudStories.forEach(s => mergedMap.set(String(s.id), s));\n\n                    const merged = Array.from(mergedMap.values())\n                        .sort((a, b) => new Date(b.createdAt || 0) - new Date(a.createdAt || 0))\n                        .slice(0, 50);\n\n                    storyActor.send({ type: 'STORY.FETCH_SUCCESS', stories: merged });\n                } else {\n                    storyActor.send({ type: 'STORY.FETCH_SUCCESS', stories: savedStories });\n                }\n            } catch (error) {\n                console.error(\"Story load error:\", error);\n                storyActor.send({ type: 'STORY.FETCH_FAILURE', error: error.message });\n            }\n        };\n\n        loadStories();\n\n        const unsubscribe = firestoreService.subscribeToStories(authUser.uid, (data) => {\n            if (!data) return;\n            // Real-time update from cloud\n            // We again need to merge or just replace?\n            // If data is the *full list* from Firestore listener, we can merge.\n            const mergedMap = new Map();\n            // We use the actor's current snapshot content or just what we have in scope?\n            // 'savedStories' is from selector, so it updates.\n            // CAUTION: This effect depends on savedStories? If so it loops?\n            // firestoreService.subscribeToStories usually returns the full collection or changes.\n            // If straightforward subscription:\n            // Let's assume data is the full list.\n            storyActor.send({ type: 'STORY.FETCH_SUCCESS', stories: data });\n        });\n\n        return () => unsubscribe();\n    }, [authUser, firestoreEnabled, cloudSynced, storyActor]); // data deps removed to avoid loops, relying on remote events\n\n    const saveStory = useCallback(async (story) => {\n        const storyId = String(Date.now());\n        const newStory = {\n            id: storyId,\n            ...story,\n            createdAt: new Date().toISOString()\n        };\n\n        storyActor.send({ type: 'STORY.CREATE_START' });\n\n        // Optimistic update via machine\n        storyActor.send({ type: 'STORY.CREATE_SUCCESS', story: newStory });\n\n        setLastSavedStory(newStory); // Emit event for UserContext/Bridge\n\n        const eventType = story.type === 'story' ? 'story_created' : 'game_created';\n        analytics.track(eventType, { title: story.title });\n\n        if (authUser && firestoreEnabled) {\n            try {\n                await firestoreService.saveStory(authUser.uid, newStory);\n                // Machine already updated theoretically.\n            } catch (e) {\n                console.error(\"Save story failed\", e);\n                storyActor.send({ type: 'STORY.CREATE_FAILURE', error: e.message });\n                // If failed, we might want to rollback?\n                // For now, simple error state.\n            }\n        }\n    }, [authUser, firestoreEnabled, storyActor]);\n\n    const deleteStory = useCallback(async (id) => {\n        const stringId = String(id);\n\n        storyActor.send({ type: 'STORY.DELETE', id: stringId });\n\n        if (authUser && firestoreEnabled) {\n            try {\n                await firestoreService.deleteStory(authUser.uid, stringId);\n            } catch (e) {\n                console.error(\"Delete story failed\", e);\n                // Rollback? state is already updated optimistically.\n                // Re-fetch?\n                storyActor.send({ type: 'STORY.FETCH_START' }); // Trigger re-sync as fallback\n            }\n        }\n    }, [authUser, firestoreEnabled, storyActor]);\n\n    const refineStory = useCallback(async (existingStory, feedback) => {\n        storyActor.send({ type: 'STORY.REFINE_START' });\n        setIsProcessing(true);\n\n        try {\n            const { NarrativeDomain } = await import('../domain/narrativeDomain');\n            const result = await NarrativeDomain.processRefinementRequest(existingStory, feedback);\n\n            if (result.isSafetyTriggered) {\n                storyActor.send({ type: 'STORY.REFINE_FAILURE', error: result.message });\n                return { success: false, message: result.message };\n            }\n\n            const updatedStory = result.data;\n            storyActor.send({ type: 'STORY.REFINE_SUCCESS', story: updatedStory });\n\n            analytics.track('story_refined', { title: updatedStory.title });\n\n            if (authUser && firestoreEnabled) {\n                await firestoreService.saveStory(authUser.uid, updatedStory);\n            }\n\n            return { success: true, story: updatedStory };\n        } catch (error) {\n            console.error(\"Refinement failed:\", error);\n            storyActor.send({ type: 'STORY.REFINE_FAILURE', error: error.message });\n            return { success: false, message: error.message };\n        } finally {\n            setIsProcessing(false);\n        }\n    }, [authUser, firestoreEnabled, storyActor]);\n\n    // EXTREME OPTIMIZATION: Memoized Context Value\n    const value = React.useMemo(() => ({\n        savedStories,\n        activeStory,\n        setActiveStory,\n        isProcessing,\n        setIsProcessing,\n        analysisResult,\n        setAnalysisResult,\n        lastSavedStory,\n        setLastSavedStory,\n        communityWorks: COMMUNITY_WORKS,\n        saveStory,\n        deleteStory,\n        refineStory\n    }), [\n        savedStories,\n        activeStory,\n        isProcessing,\n        analysisResult,\n        lastSavedStory,\n        saveStory,\n        deleteStory,\n        refineStory\n    ]);\n\n    return <StoryContext.Provider value={value}>{children}</StoryContext.Provider>;\n};\n\nexport const useStory = () => {\n    const context = useContext(StoryContext);\n    if (!context) throw new Error('useStory must be used within StoryProvider');\n    return context;\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2538, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/context/UIContext.jsx"],"sourcesContent":["'use client';\nimport React, { createContext, useContext, useState, useCallback, useEffect } from 'react';\n\nconst UIContext = createContext(null);\n\nexport const UIProvider = ({ children }) => {\n    const [currentView, setCurrentView] = useState(null);\n    const [activeTab, setActiveTab] = useState('create');\n    const [notification, setNotification] = useState(null);\n    const [toasts, setToasts] = useState([]);\n    const [showOnboarding, setShowOnboarding] = useState(false);\n\n    useEffect(() => {\n        const complete = localStorage.getItem('koza-onboarding-complete');\n        if (!complete) {\n            setShowOnboarding(true);\n        }\n    }, []);\n\n\n\n    const addToast = useCallback((type, title, message) => {\n        const id = Date.now();\n        setToasts(prev => [...prev, { id, type, title, message }]);\n        setTimeout(() => {\n            setToasts(prev => prev.filter(t => t.id !== id));\n        }, 3000);\n    }, []);\n\n    // Helper to trigger notifications\n    const triggerNotification = useCallback((type, title, message) => {\n        setNotification({ type, title, message });\n        setTimeout(() => setNotification(null), 3000);\n    }, []);\n\n    const value = {\n        currentView,\n        setCurrentView,\n        activeTab,\n        setActiveTab,\n        notification,\n        setNotification, // Exposed for legacy, but triggerNotification is preferred\n        triggerNotification,\n        toasts,\n        setToasts,\n        addToast,\n        showOnboarding,\n        setShowOnboarding\n    };\n\n    return <UIContext.Provider value={value}>{children}</UIContext.Provider>;\n};\n\nexport const useUI = () => {\n    const context = useContext(UIContext);\n    if (!context) throw new Error('useUI must be used within UIProvider');\n    return context;\n};\n"],"names":[],"mappings":";;;;;;;AACA;;;AADA;;AAGA,MAAM,0BAAY,IAAA,8KAAa,EAAC;AAEzB,MAAM,aAAa,CAAC,EAAE,QAAQ,EAAE;;IACnC,MAAM,CAAC,aAAa,eAAe,GAAG,IAAA,yKAAQ,EAAC;IAC/C,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,yKAAQ,EAAC;IAC3C,MAAM,CAAC,cAAc,gBAAgB,GAAG,IAAA,yKAAQ,EAAC;IACjD,MAAM,CAAC,QAAQ,UAAU,GAAG,IAAA,yKAAQ,EAAC,EAAE;IACvC,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,IAAA,yKAAQ,EAAC;IAErD,IAAA,0KAAS;gCAAC;YACN,MAAM,WAAW,aAAa,OAAO,CAAC;YACtC,IAAI,CAAC,UAAU;gBACX,kBAAkB;YACtB;QACJ;+BAAG,EAAE;IAIL,MAAM,WAAW,IAAA,4KAAW;4CAAC,CAAC,MAAM,OAAO;YACvC,MAAM,KAAK,KAAK,GAAG;YACnB;oDAAU,CAAA,OAAQ;2BAAI;wBAAM;4BAAE;4BAAI;4BAAM;4BAAO;wBAAQ;qBAAE;;YACzD;oDAAW;oBACP;4DAAU,CAAA,OAAQ,KAAK,MAAM;oEAAC,CAAA,IAAK,EAAE,EAAE,KAAK;;;gBAChD;mDAAG;QACP;2CAAG,EAAE;IAEL,kCAAkC;IAClC,MAAM,sBAAsB,IAAA,4KAAW;uDAAC,CAAC,MAAM,OAAO;YAClD,gBAAgB;gBAAE;gBAAM;gBAAO;YAAQ;YACvC;+DAAW,IAAM,gBAAgB;8DAAO;QAC5C;sDAAG,EAAE;IAEL,MAAM,QAAQ;QACV;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACJ;IAEA,qBAAO,6LAAC,UAAU,QAAQ;QAAC,OAAO;kBAAQ;;;;;;AAC9C;GA9Ca;KAAA;AAgDN,MAAM,QAAQ;;IACjB,MAAM,UAAU,IAAA,2KAAU,EAAC;IAC3B,IAAI,CAAC,SAAS,MAAM,IAAI,MAAM;IAC9B,OAAO;AACX;IAJa"}},
    {"offset": {"line": 2645, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/context/AppContext.jsx"],"sourcesContent":["'use client';\nimport React, { createContext, useContext, useEffect } from 'react';\nimport { useUser } from './UserContext';\nimport { useStory } from './StoryContext';\nimport { useUI } from './UIContext';\n\n// Legacy AppContext not strictly needed if we export the hook, but good for safety\nconst AppContext = createContext(null);\n\n// This provider component is now a wrapper that assumes proper nesting\n// Or better: it just returns children because logic is upstream.\n// BUT, to keep main.jsx clean, we can make AppProvider the \"Combobulator\" that nests all providers.\nimport { UserProvider } from './UserContext';\nimport { StoryProvider } from './StoryContext';\nimport { UIProvider } from './UIContext';\n\nexport const AppProvider = ({ children }) => {\n    return (\n        <UserProvider>\n            <StoryProvider>\n                <UIProvider>\n                    <AppContextBridge>{children}</AppContextBridge>\n                </UIProvider>\n            </StoryProvider>\n        </UserProvider>\n    );\n};\n\n// Internal bridge to handle side-effects between contexts (like User Level Up -> UI Notification)\nconst AppContextBridge = ({ children }) => {\n    const { lastUserEvent, setLastUserEvent, setUser } = useUser();\n    const { lastSavedStory, setLastSavedStory } = useStory();\n    const { triggerNotification, addToast } = useUI();\n\n    // Listen to Story events to update User stats\n    useEffect(() => {\n        if (!lastSavedStory) return;\n\n        setUser(prev => ({\n            ...prev,\n            storiesCreated: lastSavedStory.type === 'story' ? prev.storiesCreated + 1 : prev.storiesCreated,\n            gamesCreated: lastSavedStory.type === 'game' ? prev.gamesCreated + 1 : prev.gamesCreated\n        }));\n\n        setLastSavedStory(null); // Clear event\n    }, [lastSavedStory, setUser, setLastSavedStory]);\n\n    // Listen to User events and trigger UI\n    useEffect(() => {\n        if (!lastUserEvent) return;\n\n        if (lastUserEvent.type === 'levelup') {\n            triggerNotification('levelup', 'Seviye AtladÄ±n!', `Yeni seviye: ${lastUserEvent.level}`);\n        } else if (lastUserEvent.type === 'xp') {\n            triggerNotification('xp', `+${lastUserEvent.amount} XP`, lastUserEvent.reason);\n        } else if (lastUserEvent.type === 'achievement') {\n            lastUserEvent.achievements.forEach(ach => {\n                addToast('success', 'BaÅŸarÄ± KazanÄ±ldÄ±!', `${ach.icon} ${ach.name}`);\n            });\n        }\n\n        setLastUserEvent(null); // Clear event\n    }, [lastUserEvent, triggerNotification, addToast, setLastUserEvent]);\n\n    return children;\n};\n\n\n// Legacy Facade Hook\nexport const useApp = () => {\n    // We can't simply use useContext(AppContext) because we aren't passing a value to it anymore.\n    // Instead, we just call the individual hooks and merge them.\n    const userContext = useUser();\n    const storyContext = useStory();\n    const uiContext = useUI();\n\n    return {\n        ...userContext,\n        ...storyContext,\n        ...uiContext\n    };\n};\n"],"names":[],"mappings":";;;;;;;AACA;AACA;AACA;AACA;;;AAJA;;;;;AAMA,mFAAmF;AACnF,MAAM,2BAAa,IAAA,8KAAa,EAAC;;;;AAS1B,MAAM,cAAc,CAAC,EAAE,QAAQ,EAAE;IACpC,qBACI,6LAAC,iJAAY;kBACT,cAAA,6LAAC,mJAAa;sBACV,cAAA,6LAAC,6IAAU;0BACP,cAAA,6LAAC;8BAAkB;;;;;;;;;;;;;;;;;;;;;AAKvC;KAVa;AAYb,kGAAkG;AAClG,MAAM,mBAAmB,CAAC,EAAE,QAAQ,EAAE;;IAClC,MAAM,EAAE,aAAa,EAAE,gBAAgB,EAAE,OAAO,EAAE,GAAG,IAAA,4IAAO;IAC5D,MAAM,EAAE,cAAc,EAAE,iBAAiB,EAAE,GAAG,IAAA,8IAAQ;IACtD,MAAM,EAAE,mBAAmB,EAAE,QAAQ,EAAE,GAAG,IAAA,wIAAK;IAE/C,8CAA8C;IAC9C,IAAA,0KAAS;sCAAC;YACN,IAAI,CAAC,gBAAgB;YAErB;8CAAQ,CAAA,OAAQ,CAAC;wBACb,GAAG,IAAI;wBACP,gBAAgB,eAAe,IAAI,KAAK,UAAU,KAAK,cAAc,GAAG,IAAI,KAAK,cAAc;wBAC/F,cAAc,eAAe,IAAI,KAAK,SAAS,KAAK,YAAY,GAAG,IAAI,KAAK,YAAY;oBAC5F,CAAC;;YAED,kBAAkB,OAAO,cAAc;QAC3C;qCAAG;QAAC;QAAgB;QAAS;KAAkB;IAE/C,uCAAuC;IACvC,IAAA,0KAAS;sCAAC;YACN,IAAI,CAAC,eAAe;YAEpB,IAAI,cAAc,IAAI,KAAK,WAAW;gBAClC,oBAAoB,WAAW,mBAAmB,CAAC,aAAa,EAAE,cAAc,KAAK,EAAE;YAC3F,OAAO,IAAI,cAAc,IAAI,KAAK,MAAM;gBACpC,oBAAoB,MAAM,CAAC,CAAC,EAAE,cAAc,MAAM,CAAC,GAAG,CAAC,EAAE,cAAc,MAAM;YACjF,OAAO,IAAI,cAAc,IAAI,KAAK,eAAe;gBAC7C,cAAc,YAAY,CAAC,OAAO;kDAAC,CAAA;wBAC/B,SAAS,WAAW,qBAAqB,GAAG,IAAI,IAAI,CAAC,CAAC,EAAE,IAAI,IAAI,EAAE;oBACtE;;YACJ;YAEA,iBAAiB,OAAO,cAAc;QAC1C;qCAAG;QAAC;QAAe;QAAqB;QAAU;KAAiB;IAEnE,OAAO;AACX;GApCM;;QACmD,4IAAO;QACd,8IAAQ;QACZ,wIAAK;;;MAH7C;AAwCC,MAAM,SAAS;;IAClB,8FAA8F;IAC9F,6DAA6D;IAC7D,MAAM,cAAc,IAAA,4IAAO;IAC3B,MAAM,eAAe,IAAA,8IAAQ;IAC7B,MAAM,YAAY,IAAA,wIAAK;IAEvB,OAAO;QACH,GAAG,WAAW;QACd,GAAG,YAAY;QACf,GAAG,SAAS;IAChB;AACJ;IAZa;;QAGW,4IAAO;QACN,8IAAQ;QACX,wIAAK"}},
    {"offset": {"line": 2783, "column": 0}, "map": {"version":3,"sources":["file:///Users/orwell/KOZA/src/components/ErrorBoundary.jsx"],"sourcesContent":["'use client';\nimport React from 'react';\nimport { AlertTriangle } from 'lucide-react';\nimport { AuthProvider } from '../context/AuthContext'; // Import context\n\nclass ErrorBoundary extends React.Component {\n    constructor(props) {\n        super(props);\n        this.state = { hasError: false, error: null, errorInfo: null };\n    }\n\n    static getDerivedStateFromError(error) {\n        return { hasError: true, error };\n    }\n\n    componentDidCatch(error, errorInfo) {\n        console.error('ErrorBoundary caught:', error, errorInfo);\n        this.setState({ errorInfo });\n    }\n\n    render() {\n        if (this.state.hasError) {\n            return (\n                <div className=\"min-h-screen bg-neutral-50 flex flex-col items-center justify-center px-4\">\n                    <div className=\"max-w-md w-full bg-white rounded-2xl border border-neutral-200 p-8 text-center shadow-sm\">\n                        <div className=\"w-16 h-16 bg-red-100 rounded-full flex items-center justify-center mx-auto mb-4\">\n                            <AlertTriangle size={32} className=\"text-red-600\" />\n                        </div>\n                        <h2 className=\"text-2xl font-bold mb-2\">Bir Hata OluÅŸtu</h2>\n                        <p className=\"text-neutral-600 mb-6\">\n                            ÃœzgÃ¼nÃ¼z, beklenmeyen bir sorun oluÅŸtu. LÃ¼tfen sayfayÄ± yenileyin.\n                        </p>\n                        <button\n                            onClick={() => window.location.reload()}\n                            className=\"px-6 py-3 bg-neutral-900 text-white rounded-full font-medium hover:scale-105 transition-all shadow-lg active:scale-95\"\n                        >\n                            SayfayÄ± Yenile\n                        </button>\n                    </div>\n\n                    {/* Admin-only detailed error info */}\n                    <AdminErrorDetails error={this.state.error} errorInfo={this.state.errorInfo} />\n                </div>\n            );\n        }\n\n        return this.props.children;\n    }\n}\n\n// Separate component to use AuthContext hook or consumer safely\nimport { useAuth } from '../context/AuthContext';\nconst AdminErrorDetails = ({ error, errorInfo }) => {\n    try {\n        const { isAdmin } = useAuth();\n        if (!isAdmin || !error) return null;\n\n        return (\n            <div className=\"mt-8 max-w-2xl w-full p-6 bg-red-50 rounded-2xl border border-red-100 text-left overflow-auto animate-fade-in shadow-sm\">\n                <p className=\"font-mono text-sm text-red-700 whitespace-pre-wrap font-bold mb-2 border-b border-red-100 pb-2\">\n                    Admin View: Error Details\n                </p>\n                <p className=\"font-mono text-sm text-red-700 whitespace-pre-wrap\">\n                    {error.toString()}\n                </p>\n                {errorInfo && (\n                    <pre className=\"mt-4 font-mono text-xs text-red-600 whitespace-pre-wrap p-3 bg-white/50 rounded-xl\">\n                        {errorInfo.componentStack}\n                    </pre>\n                )}\n            </div>\n        );\n    } catch (e) {\n        // If AuthContext isn't available (e.g. error happened during provider init)\n        return null;\n    }\n};\n\nexport default ErrorBoundary;\n"],"names":[],"mappings":";;;;;AACA;AACA;AACA,oOAAuD,iBAAiB;AAHxE;;;;;AAKA,MAAM,sBAAsB,wKAAK,CAAC,SAAS;IACvC,YAAY,KAAK,CAAE;QACf,KAAK,CAAC;QACN,IAAI,CAAC,KAAK,GAAG;YAAE,UAAU;YAAO,OAAO;YAAM,WAAW;QAAK;IACjE;IAEA,OAAO,yBAAyB,KAAK,EAAE;QACnC,OAAO;YAAE,UAAU;YAAM;QAAM;IACnC;IAEA,kBAAkB,KAAK,EAAE,SAAS,EAAE;QAChC,QAAQ,KAAK,CAAC,yBAAyB,OAAO;QAC9C,IAAI,CAAC,QAAQ,CAAC;YAAE;QAAU;IAC9B;IAEA,SAAS;QACL,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,EAAE;YACrB,qBACI,6LAAC;gBAAI,WAAU;;kCACX,6LAAC;wBAAI,WAAU;;0CACX,6LAAC;gCAAI,WAAU;0CACX,cAAA,6LAAC,4OAAa;oCAAC,MAAM;oCAAI,WAAU;;;;;;;;;;;0CAEvC,6LAAC;gCAAG,WAAU;0CAA0B;;;;;;0CACxC,6LAAC;gCAAE,WAAU;0CAAwB;;;;;;0CAGrC,6LAAC;gCACG,SAAS,IAAM,OAAO,QAAQ,CAAC,MAAM;gCACrC,WAAU;0CACb;;;;;;;;;;;;kCAML,6LAAC;wBAAkB,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK;wBAAE,WAAW,IAAI,CAAC,KAAK,CAAC,SAAS;;;;;;;;;;;;QAGvF;QAEA,OAAO,IAAI,CAAC,KAAK,CAAC,QAAQ;IAC9B;AACJ;;AAIA,MAAM,oBAAoB,CAAC,EAAE,KAAK,EAAE,SAAS,EAAE;IAC3C,IAAI;QACA,MAAM,EAAE,OAAO,EAAE,GAAG,IAAA,4IAAO;QAC3B,IAAI,CAAC,WAAW,CAAC,OAAO,OAAO;QAE/B,qBACI,6LAAC;YAAI,WAAU;;8BACX,6LAAC;oBAAE,WAAU;8BAAiG;;;;;;8BAG9G,6LAAC;oBAAE,WAAU;8BACR,MAAM,QAAQ;;;;;;gBAElB,2BACG,6LAAC;oBAAI,WAAU;8BACV,UAAU,cAAc;;;;;;;;;;;;IAK7C,EAAE,OAAO,GAAG;QACR,4EAA4E;QAC5E,OAAO;IACX;AACJ;KAxBM;uCA0BS"}}]
}